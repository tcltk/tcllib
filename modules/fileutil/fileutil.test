# -*- tcl -*-
# Tests for the find function.
#
# Sourcing this file into Tcl runs the tests and generates output for errors.
# No output means no errors were found.
#
# Copyright (c) 1998-2000 by Ajuba Solutions.
# Copyright (c) 2001 by ActiveState Tool Corp.
# All rights reserved.
#
# RCS: @(#) $Id: fileutil.test,v 1.47 2006/09/15 05:07:26 andreas_kupries Exp $

# -------------------------------------------------------------------------

source [file join \
	[file dirname [file dirname [file join [pwd] [info script]]]] \
	devtools testutilities.tcl]

testsNeedTcl     8.2
testsNeedTcltest 1.0

support {
    useTcllibFile fumagic/fumagic.testsupport
    use           cmdline/cmdline.tcl cmdline
}
testing {
    useLocal fileutil.tcl fileutil
}

set oldenv [array get env]

# -------------------------------------------------------------------------
# Now the package specific tests....

# Build a sample tree to search
# Structure
#
#	dir
#	+--{find 1}
#          +--{find 2}
#          |  +--{file* 2}  (This file is unix only)
#          +--{file 1}
#
#       dir2
#       +-- dotfiles
#           +-- .foo
#           +-- foo

makeDirectory {find 1}
makeDirectory [file join {find 1} {find 2}]
makeFile "" [file join {find 1} {file [1]}]

if {0 != [string compare $::tcl_platform(platform) windows]} {
    makeFile "test" [file join {find 1} {find 2} {file* 2}]
}

set dir $::tcltest::temporaryDirectory

makeDirectory dotfiles
makeFile "" [file join dotfiles foo]
makeFile "" [file join dotfiles .foo]



proc fileIsBiggerThan {s f} {
    expr {![file isdirectory $f] && [file size $f] > $s}
}

test find-1.1 {standard recursive find} {macOrUnix} {
    lsort [fileutil::find [file join $dir {find 1}]]
} [list [file join $dir {find 1} {file [1]}] \
	[file join $dir {find 1} {find 2}] \
	[file join $dir {find 1} {find 2} {file* 2}]]

test find-1.2 {standard recursive find} {win} {
    lsort [fileutil::find [file join $dir {find 1}]]
} [list [file join $dir {find 1} {file [1]}] \
	[file join $dir {find 1} {find 2}]]

test find-1.3 {find directories} {
    fileutil::find [file join $dir {find 1}] {file isdirectory}
} [list [file join $dir {find 1} {find 2}]]

test find-1.4 {find files bigger than a given size} {macOrUnix} {
    fileutil::find [file join $dir {find 1}] {fileIsBiggerThan 1}
} [list [file join $dir {find 1} {find 2} {file* 2}]]


# Extend the previous sample tree
# Extended structure:
#
#	dir
#	+--{find 1}
#          +--{find 2}          <----------+
#          |  +--{file* 2}		   |
#          |  +--{file 3} --> ../{find 2} -+
#          +--{file [1]}

test find-1.5 {handling of circular links} {unix} {
    catch {file delete -force [file join $dir {find 1} {find 2} {file 3}]}
    exec ln -s [file join .. {find 2}] [file join $dir {find 1} {find 2} {file 3}]

    # Find has to skip '{file 3}'. Actually not. It should include
    # {file 3} itself in the result, but must not follow it further.

    lsort [fileutil::find [file join $dir {find 1}]]
} [list [file join $dir {find 1} {file [1]}] \
	[file join $dir {find 1} {find 2}] \
	[file join $dir {find 1} {find 2} {file 3}] \
	[file join $dir {find 1} {find 2} {file* 2}]]

test find-1.6 {find file} {
    ::fileutil::find [file join $dir {find 1} {file [1]}]
} [list [file join $dir {find 1} {file [1]}]]

test find-1.7 {find file with filter} {
    ::fileutil::find [file join $dir {find 1} {file [1]}] {file isfile}
} [list [file join $dir {find 1} {file [1]}]]

test find-1.8 {find file with filter - negative} {
    ::fileutil::find [file join $dir {find 1} {file [1]}] {file isdirectory}
} {}

# Behaviour of find with regard to dot-files.

test find-1.9 {find file dot-files} {
    lsort [::fileutil::find [file join $dir dotfiles]]
} [list \
	[file join $dir dotfiles .foo] \
	[file join $dir dotfiles foo]  \
	]

# find by pattern tests

test find-2.0 {find by pattern} {
    list [catch {
        ::fileutil::findByPattern $dir -glob {fil*} foo
    } err] $err
} {1 {wrong#args for "::fileutil::findByPattern", should be "::fileutil::findByPattern basedir ?-regexp|-glob? ?--? patterns"}}

test find-2.1 {find by pattern} {
    list [catch {
        ::fileutil::findByPattern $dir -glob
    } err] $err
} {1 {wrong#args for "::fileutil::findByPattern", should be "::fileutil::findByPattern basedir ?-regexp|-glob? ?--? patterns"}}

test find-2.2 {find by pattern} {macOrUnix} {
    lsort [::fileutil::findByPattern [file join $dir {find 1}] -glob {fil*}]
} [list [file join $dir {find 1} {file [1]}] \
	[file join $dir {find 1} {find 2} {file 3}] \
	[file join $dir {find 1} {find 2} {file* 2}] \
	]

test find-2.3 {find by pattern} {win} {
    lsort [::fileutil::findByPattern [file join $dir {find 1}] -glob {fil*}]
} [list [file join $dir {find 1} {file [1]}]]

test find-2.4 {find by pattern} {
    lsort [::fileutil::findByPattern [file join $dir {find 1}] -regexp {.*\\[1\\]$}]
} [list [file join $dir {find 1} {file [1]}]]

# Finding inaccessible directories (unix only) (I do not know howe
# make the directory inaccessible on Windows, and then reaccessible
# again)

makeDirectory find3
makeDirectory find3/find4
makeFile {}   find3/find4/file5

if {0 != [string compare $::tcl_platform(platform) windows]} {
    exec chmod -x [file join $dir find3/find4]
}

test find-3.0 {inaccessible directory} {unix} {
    lsort [fileutil::find [file join $dir find3]]
} [list [file join $dir find3 find4]]

test find-3.1 {inaccessible directory} {unix} {
    lsort [fileutil::find [file join $dir find3 find4]]
} {}

if {0 != [string compare $::tcl_platform(platform) windows]} {
    exec chmod +x [file join $dir find3/find4]
}

# Build a sample tree to search
makeDirectory grepTest
makeFile "zoop" [file join $dir grepTest {file [1]}]
if {0 != [string compare $::tcl_platform(platform) windows]} {
    makeFile "zoo\nbart"  [file join $dir grepTest {file* 2}]
}

test grep-1.1 {normal grep} {macOrUnix} {
    lsort [fileutil::grep "zoo" [glob [file join $dir grepTest *]]]
} [list "[file join $dir grepTest {file [1]}]:1:zoop" \
	"[file join $dir grepTest {file* 2}]:1:zoo"]

test grep-1.2 {more restrictive grep} {
    lsort [fileutil::grep "zoo." [glob [file join $dir grepTest *]]]
} [list "[file join $dir grepTest {file [1]}]:1:zoop"]

test grep-1.3 {more restrictive grep} {macOrUnix} {
    lsort [fileutil::grep "bar" [glob [file join $dir grepTest *]]]
} [list "[file join $dir grepTest {file* 2}]:2:bart"]




test cat-1.1 {cat} {
    set path [makeFile "foo\nbar\nbaz\n" {cat [1]}]

    set data [fileutil::cat $path]

    removeFile {cat [1]}
    set data
} "foo\nbar\nbaz\n"

test cat-1.2 {cat multiple files} {macOrUnix} {
    set pathA [makeFile "foo\nbar\nbaz\n" {cat [1]}]
    set pathB [makeFile "bebop" {cat* 2}]

    set data [fileutil::cat $pathA $pathB]

    removeFile {cat [1]}
    removeFile {cat* 2}
    set data
} "foo\nbar\nbaz\nbebop\n"


test cat-1.3.0 {cat, option processing} {
    set path [makeFile "foo\r\nbar\r\nbaz\r\n" {cat [1]}]

    set data [fileutil::cat -translation binary $path]

    removeFile {cat [1]}
    set data
} "foo\r\nbar\r\nbaz\r\n"

test cat-1.3.1 {cat, option processing} {
    set path [makeFile "foo\r\nbar\r\nbaz\r\n" {cat [1]}]

    set data [fileutil::cat $path]

    removeFile {cat [1]}
    set data
} "foo\nbar\nbaz\n"

test cat-1.4 {cat multiple files} {macOrUnix} {
    set pathA [makeFile "foo\r\nbar\r\nbaz\r\n" {cat [1]}]
    set pathB [makeFile "bebop\r\nsnoof" {cat* 2}]

    set data [fileutil::cat $pathA -translation binary $pathB]

    removeFile {cat [1]}
    removeFile {cat* 2}
    set data
} "foo\nbar\nbaz\nbebop\r\nsnoof\n"

test cat-1.5.0 {cat, bad arguments} {
    catch {fileutil::cat} msg
    set msg
} {wrong#args: should be fileutil::cat ?-eofchar|-translation|-encoding arg?+ file ...}

test cat-1.5.1 {cat, bad arguments} {
    catch {fileutil::cat -translation} msg
    set msg
} {wrong#args: should be fileutil::cat ?-eofchar|-translation|-encoding arg?+ file ...}

test cat-1.5.2 {cat, bad arguments} {
    catch {fileutil::cat -bogus foo} msg
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}

set xpath [makeFile {} {cat [2]}]
removeFile {cat [2]}

test cat-1.5.3 {cat, bad arguments, unreadable file} {unixOnly} {
    set path [makeFile {} {cat [2]}]
    file attributes $path -permissions 0000

    catch {fileutil::cat $path} msg

    file attributes $path -permissions 0600
    removeFile {cat [2]}
    set msg
} "Cannot read file \"$xpath\", read access is denied"

test cat-1.5.4 {cat, bad arguments, non-existing file} {unixOnly} {
    set path [makeFile {} {cat [2]}]
    removeFile {cat [2]}

    catch {fileutil::cat $path} msg

    set msg
} "Cannot read file \"$xpath\", does not exist"

test cat-1.5.5 {cat, bad arguments, directory} {unixOnly} {
    set path [makeDirectory {cat [2]}]

    catch {fileutil::cat $path} msg

    removeDirectory {cat [2]}
    set msg
} "Cannot read file \"$xpath\", is not a file"


test writefile-1.0 {writeFile, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::writeFile $path {}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test writefile-1.1 {writeFile, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::writeFile $path {}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test writefile-1.2 {writeFile, wrong#args} {
    catch {fileutil::writeFile irrelevant} msg
    set msg
} {wrong#args: should be fileutil::writeFile ?-eofchar|-translation|-encoding arg? file data}

test writefile-1.3 {writeFile, wrong#args} {
    catch {fileutil::writeFile} msg
    set msg
} {wrong#args: should be fileutil::writeFile ?-eofchar|-translation|-encoding arg? file data}

test writefile-1.4 {writeFile, wrong#args} {
    catch {fileutil::writeFile a b c} msg
    set msg
} {wrong#args: should be fileutil::writeFile ?-eofchar|-translation|-encoding arg? file data}

test writefile-1.5 {writeFile, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::writeFile -bogus $path {}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}


test writefile-2.0 {writeFile, create file} {
    set path [makeFile {} out]
    removeFile out

    set     res {}
    lappend res [file exists $path]

    fileutil::writeFile $path dummy

    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {0 1 dummy}

test writefile-2.1 {writeFile, replace file} {
    set path [makeFile {} out]

    set     res {}
    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    fileutil::writeFile $path dummy

    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {1 {
} 1 dummy}

test writefile-2.2 {writeFile, translation 1} {
    set path [makeFile {} out]

    fileutil::writeFile $path "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\nfoo"

test writefile-2.3 {writeFile, translation 2} {
    set path [makeFile {} out]

    fileutil::writeFile -translation crlf $path "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\r\nfoo"

test appendtofile-1.0 {appendToFile, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::appendToFile $path {}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test appendtofile-1.1 {appendToFile, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::appendToFile $path {}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test appendtofile-1.2 {appendToFile, wrong#args} {
    catch {fileutil::appendToFile irrelevant} msg
    set msg
} {wrong#args: should be fileutil::appendToFile ?-eofchar|-translation|-encoding arg? file data}

test appendtofile-1.3 {appendToFile, wrong#args} {
    catch {fileutil::appendToFile} msg
    set msg
} {wrong#args: should be fileutil::appendToFile ?-eofchar|-translation|-encoding arg? file data}

test appendtofile-1.4 {appendToFile, wrong#args} {
    catch {fileutil::appendToFile a b c} msg
    set msg
} {wrong#args: should be fileutil::appendToFile ?-eofchar|-translation|-encoding arg? file data}

test appendtofile-1.5 {appendToFile, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::appendToFile -bogus $path {}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}


test appendtofile-2.0 {appendToFile, create file} {
    set path [makeFile {} out]
    removeFile out

    set     res {}
    lappend res [file exists $path]

    fileutil::appendToFile $path dummy

    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {0 1 dummy}

test appendtofile-2.1 {appendToFile, true append} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn|

    set     res {}
    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    fileutil::appendToFile $path dummy

    lappend res [file exists $path]
    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {1 aragorn| 1 aragorn|dummy}

test appendtofile-2.2 {appendToFile, translation 1} {
    set path [makeFile {} out]
    fileutil::writeFile $path {}

    fileutil::appendToFile $path "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\nfoo"

test appendtofile-2.3 {appendToFile, translation 2} {
    set path [makeFile {} out]
    fileutil::writeFile $path {}

    fileutil::appendToFile -translation crlf $path "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\r\nfoo"


test insertintofile-1.0 {insertIntoFile, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::insertIntoFile $path 0 {}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test insertintofile-1.1 {insertIntoFile, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::insertIntoFile $path 0 {}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test insertintofile-1.2 {insertIntoFile, missing file} {
    set path [makeFile {} missing]
    removeFile missing

    catch {fileutil::insertIntoFile $path 0 {}} msg

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", does not exist}

test insertintofile-1.3 {insertIntoFile, wrong#args} {
    catch {fileutil::insertIntoFile irrelevant} msg
    set msg
} {wrong#args: should be fileutil::insertIntoFile ?-eofchar|-translation|-encoding arg? file at data}

test insertintofile-1.4 {insertIntoFile, wrong#args} {
    catch {fileutil::insertIntoFile} msg
    set msg
} {wrong#args: should be fileutil::insertIntoFile ?-eofchar|-translation|-encoding arg? file at data}

test insertintofile-1.5 {insertIntoFile, wrong#args} {
    catch {fileutil::insertIntoFile a b c d} msg
    set msg
} {wrong#args: should be fileutil::insertIntoFile ?-eofchar|-translation|-encoding arg? file at data}

test insertintofile-1.6 {insertIntoFile, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::insertIntoFile -bogus $path {}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}

test insertintofile-1.7 {insertIntoFile, non-integer insertion point} {
    set path [makeFile {} dummy]

    catch {fileutil::insertIntoFile $path foo {}} msg

    removeFile dummy
    set msg
} {Expected integer but got "foo"}

test insertintofile-1.8 {insertIntoFile, negative insertion point} {
    set path [makeFile {} dummy]

    catch {fileutil::insertIntoFile $path -1 {}} msg

    removeFile dummy
    set msg
} {Bad insertion point -1, before start of data}

test insertintofile-1.9 {insertIntoFile, insertion point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::insertIntoFile $path 4 {}} msg

    removeFile dummy
    set msg
} {Bad insertion point 4, behind end of data}

# Needed for 1.10
set path [makeFile {} dummy]
set  beyond [file size $path]
incr beyond
removeFile dummy

test insertintofile-1.10 {insertIntoFile, insertion point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::insertIntoFile $path $beyond {}} msg

    removeFile dummy
    set msg
} "Bad insertion point $beyond, behind end of data"


test insertintofile-2.0 {insertIntoFile, insert at front} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::insertIntoFile $path 0 dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn dummy|aragorn}

test insertintofile-2.1 {insertIntoFile, insert degenerated to append} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::insertIntoFile $path \
	    [file size $path] dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aragorndummy|}

test insertintofile-2.2 {insertIntoFile, insert in the middle} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::insertIntoFile $path 3 dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aradummy|gorn}

test insertintofile-2.3 {insertIntoFile, insert nothing} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::insertIntoFile $path 3 {}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aragorn}

test insertintofile-2.4 {insertIntoFile, translation 1} {
    set path [makeFile {} out]
    fileutil::writeFile $path {}

    fileutil::insertIntoFile $path 0 "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\nfoo"

test insertintofile-2.5 {insertIntoFile, translation 2} {
    set path [makeFile {} out]
    fileutil::writeFile $path {}

    fileutil::insertIntoFile -translation crlf $path 0 "dummy\nfoo"
    set res [fileutil::cat -translation binary $path]

    removeFile out
    set res
} "dummy\r\nfoo"


test removefromfile-1.0 {removeFromFile, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::removeFromFile $path 0 {}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test removefromfile-1.1 {removeFromFile, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::removeFromFile $path 0 {}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test removefromfile-1.2 {removeFromFile, missing file} {
    set path [makeFile {} missing]
    removeFile missing

    catch {fileutil::removeFromFile $path 0 {}} msg

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", does not exist}

test removefromfile-1.3 {removeFromFile, wrong#args} {
    catch {fileutil::removeFromFile irrelevant} msg
    set msg
} {wrong#args: should be fileutil::removeFromFile ?-eofchar|-translation|-encoding arg? file at n}

test removefromfile-1.4 {removeFromFile, wrong#args} {
    catch {fileutil::removeFromFile} msg
    set msg
} {wrong#args: should be fileutil::removeFromFile ?-eofchar|-translation|-encoding arg? file at n}

test removefromfile-1.5 {removeFromFile, wrong#args} {
    catch {fileutil::removeFromFile a b c d} msg
    set msg
} {wrong#args: should be fileutil::removeFromFile ?-eofchar|-translation|-encoding arg? file at n}

test removefromfile-1.6 {removeFromFile, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile -bogus $path {}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}

test removefromfile-1.7 {removeFromFile, non-integer removal point} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path foo 0} msg

    removeFile dummy
    set msg
} {Expected integer but got "foo"}

test removefromfile-1.8 {removeFromFile, negative removal point} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path -1 0} msg

    removeFile dummy
    set msg
} {Bad removal point -1, before start of data}

test removefromfile-1.9 {removeFromFile, removal point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path 4 0} msg

    removeFile dummy
    set msg
} {Bad removal point 4, behind end of data}

set  path   [makeFile {} dummy]
set  beyond [file size $path]
incr beyond
removeFile dummy

test removefromfile-1.10 {removeFromFile, removal point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path $beyond 0} msg

    removeFile dummy
    set msg
} "Bad removal point $beyond, behind end of data"

test removefromfile-1.11 {removeFromFile, non-integer removal size} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path 0 foo} msg

    removeFile dummy
    set msg
} {Expected integer but got "foo"}

test removefromfile-1.12 {removeFromFile, negative removal size} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path 0 -1} msg

    removeFile dummy
    set msg
} {Bad removal size -1}

test removefromfile-1.13 {removeFromFile, removal size beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path 0 4} msg

    removeFile dummy
    set msg
} {Bad removal size 4, going behind end of data}

set  path   [makeFile {} dummy]
set  beyond [file size $path]
incr beyond
removeFile dummy

test removefromfile-1.14 {removeFromFile, removal point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::removeFromFile $path 0 $beyond} msg

    removeFile dummy
    set msg
} "Bad removal size $beyond, going behind end of data"


test removefromfile-2.0 {removeFromFile, remove at front} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::removeFromFile $path 0 3

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn gorn}

test removefromfile-2.1 {removeFromFile, removal at end} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::removeFromFile $path 3 4

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara}

test removefromfile-2.2 {removeFromFile, removal in the middle} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::removeFromFile $path 3 1

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn araorn}

test removefromfile-2.3 {removeFromFile, remove nothing} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::removeFromFile $path 3 0

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aragorn}


test replaceinfile-1.0 {replaceInFile, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::replaceInFile $path 0 0 {}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test replaceinfile-1.1 {replaceInFile, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::replaceInFile $path 0 0 {}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test replaceinfile-1.2 {replaceInFile, missing file} {
    set path [makeFile {} missing]
    removeFile missing

    catch {fileutil::replaceInFile $path 0 0 {}} msg

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", does not exist}

test replaceinfile-1.3 {replaceInFile, wrong#args} {
    catch {fileutil::replaceInFile irrelevant} msg
    set msg
} {wrong#args: should be fileutil::replaceInFile ?-eofchar|-translation|-encoding arg? file at n data}

test replaceinfile-1.4 {replaceInFile, wrong#args} {
    catch {fileutil::replaceInFile} msg
    set msg
} {wrong#args: should be fileutil::replaceInFile ?-eofchar|-translation|-encoding arg? file at n data}

test replaceinfile-1.5 {replaceInFile, wrong#args} {
    catch {fileutil::replaceInFile a b c d e} msg
    set msg
} {wrong#args: should be fileutil::replaceInFile ?-eofchar|-translation|-encoding arg? file at n data}

test replaceinfile-1.6 {replaceInFile, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile -bogus $path {}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}

test replaceinfile-1.7 {replaceInFile, non-integer replacement point} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path foo 0 x} msg

    removeFile dummy
    set msg
} {Expected integer but got "foo"}

test replaceinfile-1.8 {replaceInFile, negative replacement point} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path -1 0 x} msg

    removeFile dummy
    set msg
} {Bad replacement point -1, before start of data}

test replaceinfile-1.9 {replaceInFile, replacement point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path 4 0 x} msg

    removeFile dummy
    set msg
} {Bad replacement point 4, behind end of data}

set  path   [makeFile {} dummy]
set  beyond [file size $path]
incr beyond
removeFile dummy

test replaceinfile-1.10 {replaceInFile, replacement point beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path $beyond 0 x} msg

    removeFile dummy
    set msg
} "Bad replacement point $beyond, behind end of data"

test replaceinfile-1.11 {replaceInFile, non-integer replacement size} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path 0 foo x} msg

    removeFile dummy
    set msg
} {Expected integer but got "foo"}

test replaceinfile-1.12 {replaceInFile, negative replacement size} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path 0 -1 x} msg

    removeFile dummy
    set msg
} {Bad replacement size -1}

test replaceinfile-1.13 {replaceInFile, replacement size beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path 0 4 x} msg

    removeFile dummy
    set msg
} {Bad replacement size 4, going behind end of data}

set  path   [makeFile {} dummy]
set  beyond [file size $path]
incr beyond
removeFile dummy

test replaceinfile-1.14 {replaceInFile, replacement size beyond end-of-file} {
    set path [makeFile {} dummy]

    catch {fileutil::replaceInFile $path 0 $beyond x} msg

    removeFile dummy
    set msg
} "Bad replacement size $beyond, going behind end of data"


test replaceinfile-2.0 {replaceInFile, replace at front, remove} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 0 3 {}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn gorn}

test replaceinfile-2.1 {replaceInFile, replacement at end, remove} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 4 {}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara}

test replaceinfile-2.2 {replaceInFile, replacement in the middle, remove} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 1 {}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn araorn}

test replaceinfile-2.3 {replaceInFile, replace nothing} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 0 {}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aragorn}

test replaceinfile-2.4 {replaceInFile, replace at front, insert} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 0 0 dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn dummy|aragorn}

test replaceinfile-2.5 {replaceInFile, replacement at end, append} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 7 0 |dummy

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn aragorn|dummy}

test replaceinfile-2.6 {replaceInFile, replacement in the middle, insert} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 0 |dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara|dummy|gorn}

test replaceinfile-2.7 {replaceInFile, replace at front, expand} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 0 3 dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn dummy|gorn}

test replaceinfile-2.8 {replaceInFile, replacement at end, expand} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 4 |dummy

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara|dummy}

test replaceinfile-2.9 {replaceInFile, replacement in the middle, expand} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 1 |dummy|

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara|dummy|orn}

test replaceinfile-2.10 {replaceInFile, replace at front, shrink} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 0 3 |

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn |gorn}

test replaceinfile-2.11 {replaceInFile, replacement at end, shrink} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 4 |

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara|}

test replaceinfile-2.12 {replaceInFile, replacement in the middle, shrink} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::replaceInFile $path 3 3 |

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn ara|n}


test updateinplace-1.0 {updateInPlace, unwriteable file} {unixOnly} {
    set path [makeFile {} unwritable]
    file attributes $path -permissions 0000

    catch {fileutil::updateInPlace $path {string map {}}} msg

    file attributes $path -permissions 0600
    removeFile unwritable

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", write access is denied}

test updateinplace-1.1 {updateInPlace, not a file} {unixOnly} {
    set path [makeDirectory notafile]

    catch {fileutil::updateInPlace $path {string map {}}} msg

    removeDirectory notafile
    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", is not a file}

test updateinplace-1.2 {updateInPlace, missing file} {
    set path [makeFile {} missing]
    removeFile missing

    catch {fileutil::updateInPlace $path {string map {}}} msg

    regsub $path $msg @ msg
    set msg
} {Cannot use file "@", does not exist}

test updateinplace-1.3 {updateInPlace, wrong#args} {
    catch {fileutil::updateInPlace irrelevant} msg
    set msg
} {wrong#args: should be fileutil::updateInPlace ?-eofchar|-translation|-encoding arg? file cmd}

test updateinplace-1.4 {updateInPlace, wrong#args} {
    catch {fileutil::updateInPlace} msg
    set msg
} {wrong#args: should be fileutil::updateInPlace ?-eofchar|-translation|-encoding arg? file cmd}

test updateinplace-1.5 {updateInPlace, wrong#args} {
    catch {fileutil::updateInPlace a b c} msg
    set msg
} {wrong#args: should be fileutil::updateInPlace ?-eofchar|-translation|-encoding arg? file cmd}

test updateinplace-1.6 {updateInPlace, bad option} {
    set path [makeFile {} dummy]

    catch {fileutil::updateInPlace -bogus $path {string map {}}} msg

    removeFile dummy
    set msg
} {Bad option "-bogus", expected one of -encoding, -eofchar, or -translation}

test updateinplace-1.7 {updateInPlace, bogus cmd} {
    # Error leaves input file unchanged.
    set path [makeFile {} dummy]
    fileutil::writeFile $path aragorn

    catch {fileutil::updateInPlace $path bogus} msg

    set msg [list $msg [fileutil::cat $path]]
    removeFile dummy
    set msg
} {{invalid command name "bogus"} aragorn}


test updateinplace-2.0 {updateInPlace, string map} {
    set path [makeFile {} out]
    fileutil::writeFile $path aragorn

    set     res {}
    lappend res [fileutil::cat $path]

    fileutil::updateInPlace $path {string map {a | r =}}

    lappend res [fileutil::cat $path]

    removeFile out
    set res
} {aragorn |=|go=n}

# -------------------------------------------------------------------------
# In 8.3+ we can use symbolic permissions, i.e. strings like u+r, or
# ugo-r when invoking 'file attributes'. This feature is however not
# available in Tcl 8.2, the lowest revision supported by the
# package. So we make do without them and use absolute permissions
# instead.

# 644 = -rw-r--r--
# 700 = -rwx------
# 600 = -rw-------
# 500 = -r-x------
# 300 = --wx------

proc makewritable {path enable} {
    global tcl_platform
    if {[string equal $tcl_platform(platform) windows]} {
	set ro [expr {!$enable}]
	file attributes $path -readonly $ro
    } else {
	set mode [expr {$enable ? "700" : "500"}]
	file attributes $path -permissions 00$mode
    }
    return
}

proc makereadable {path enable} {
    global tcl_platform
    if {[string equal $tcl_platform(platform) windows]} {
	return -code error "Can't do that on Windows"
    } else {
	set mode [expr {$enable ? "700" : "300"}]
	file attributes $path -permissions 00$mode
    }
    return
}

proc makeexecutable {path enable} {
    global tcl_platform
    if {[string equal $tcl_platform(platform) windows]} {
	return -code error "Can't do that on Windows"
    } else {
	set mode [expr {$enable ? "700" : "600"}]
	file attributes $path -permissions 00$mode
    }
    return
}

set xpath [makeFile {} x]
removeFile x

test test-1.0.0 {test read} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 1

    set x PRE
    set res [list [fileutil::test $path read x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-1.0.1 {test read, no variable} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 1

    set x PRE
    set res [list [fileutil::test $path read] $x]
    removeFile x
    set res
} {1 PRE}

test test-1.0.2 {test !read} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path read x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Read access is denied"]

test test-1.0.3 {test !read, no variable} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path read] $x]
    removeFile x
    set res
} {0 PRE}

test test-1.0.4 {test !read, no label} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path read x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Read access is denied"]

test test-2.0.0 {test write} {
    set path [makeFile {} x]
    makewritable $path 1

    set x PRE
    set res [list [fileutil::test $path write x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-2.0.1 {test write, no variable} {
    set path [makeFile {} x]
    makewritable $path 1

    set x PRE
    set res [list [fileutil::test $path write] $x]
    removeFile x
    set res
} {1 PRE}

test test-2.0.2 {test !write} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path write x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Write access is denied"]

test test-2.0.3 {test !write, no variable} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path write] $x]
    removeFile x
    set res
} {0 PRE}

test test-2.0.4 {test !write, no label} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path write x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Write access is denied"]

test test-3.0.0 {test exists} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path exists x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-3.0.1 {test exists, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path exists] $x]
    removeFile x
    set res
} {1 PRE}

test test-3.0.2 {test !exists} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path exists x TEST] $x]
    set res
} [list 0 "TEST \"$xpath\": Does not exist"]

test test-3.0.3 {test !exists, no variable} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path exists] $x]
    set res
} {0 PRE}

test test-3.0.4 {test !exists, no label} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path exists x] $x]
    set res
} [list 0 "\"$xpath\": Does not exist"]

test test-4.0.0 {test file} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path file x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-4.0.1 {test file, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path file] $x]
    removeFile x
    set res
} {1 PRE}

test test-4.0.2 {test !file} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path file x TEST] $x]
    removeDirectory x
    set res
} [list 0 "TEST \"$xpath\": Is not a file"]

test test-4.0.3 {test !file, no variable} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path file] $x]
    removeDirectory x
    set res
} {0 PRE}

test test-4.0.4 {test !file, no label} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path file x] $x]
    removeDirectory x
    set res
} [list 0 "\"$xpath\": Is not a file"]

test test-5.0.0 {test dir} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path dir x TEST] $x]
    removeDirectory x
    set res
} {1 PRE}

test test-5.0.1 {test dir, no variable} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path dir] $x]
    removeDirectory x
    set res
} {1 PRE}

test test-5.0.2 {test !dir} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path dir x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Is not a directory"]

test test-5.0.3 {test !dir, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path dir] $x]
    removeFile x
    set res
} {0 PRE}

test test-5.0.4 {test !dir, no label} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path dir x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Is not a directory"]

test test-6.0.0 {test exec} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 1

    set x PRE
    set res [list [fileutil::test $path exec x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-6.0.1 {test exec, no variable} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 1

    set x PRE
    set res [list [fileutil::test $path exec] $x]
    removeFile x
    set res
} {1 PRE}

test test-6.0.2 {test !exec} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path exec x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Is not executable"]

test test-6.0.3 {test !exec, no variable} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path exec] $x]
    removeFile x
    set res
} {0 PRE}

test test-6.0.4 {test !exec, no label} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path exec x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Is not executable"]



test test-1.1.0 {test read} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 1

    set x PRE
    set res [list [fileutil::test $path r x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-1.1.1 {test read, no variable} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 1

    set x PRE
    set res [list [fileutil::test $path r] $x]
    removeFile x
    set res
} {1 PRE}

test test-1.1.2 {test !read} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path r x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Read access is denied"]

test test-1.1.3 {test !read, no variable} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path r] $x]
    removeFile x
    set res
} {0 PRE}

test test-1.1.4 {test !read, no label} {unixOnly} {
    set path [makeFile {} x]
    makereadable $path 0

    set x PRE
    set res [list [fileutil::test $path r x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Read access is denied"]

test test-2.1.0 {test write} {
    set path [makeFile {} x]
    makewritable $path 1

    set x PRE
    set res [list [fileutil::test $path w x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-2.1.1 {test write, no variable} {
    set path [makeFile {} x]
    makewritable $path 1

    set x PRE
    set res [list [fileutil::test $path w] $x]
    removeFile x
    set res
} {1 PRE}

test test-2.1.2 {test !write} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path w x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Write access is denied"]

test test-2.1.3 {test !write, no variable} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path w] $x]
    removeFile x
    set res
} {0 PRE}

test test-2.1.4 {test !write, no label} {
    set path [makeFile {} x]
    makewritable $path 0

    set x PRE
    set res [list [fileutil::test $path w x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Write access is denied"]

test test-3.1.0 {test exists} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path e x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-3.1.1 {test exists, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path e] $x]
    removeFile x
    set res
} {1 PRE}

test test-3.1.2 {test !exists} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path e x TEST] $x]
    set res
} [list 0 "TEST \"$xpath\": Does not exist"]

test test-3.1.3 {test !exists, no variable} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path e] $x]
    set res
} {0 PRE}

test test-3.1.4 {test !exists, no label} {
    set path [makeFile {} x]
    removeFile x

    set x PRE
    set res [list [fileutil::test $path e x] $x]
    set res
} [list 0 "\"$xpath\": Does not exist"]

test test-4.1.0 {test file} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path f x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-4.1.1 {test file, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path f] $x]
    removeFile x
    set res
} {1 PRE}

test test-4.1.2 {test !file} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path f x TEST] $x]
    removeDirectory x
    set res
} [list 0 "TEST \"$xpath\": Is not a file"]

test test-4.1.3 {test !file, no variable} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path f] $x]
    removeDirectory x
    set res
} {0 PRE}

test test-4.1.4 {test !file, no label} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path f x] $x]
    removeDirectory x
    set res
} [list 0 "\"$xpath\": Is not a file"]

test test-5.1.0 {test dir} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path d x TEST] $x]
    removeDirectory x
    set res
} {1 PRE}

test test-5.1.1 {test dir, no variable} {
    set path [makeDirectory x]

    set x PRE
    set res [list [fileutil::test $path d] $x]
    removeDirectory x
    set res
} {1 PRE}

test test-5.1.2 {test !dir} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path d x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Is not a directory"]

test test-5.1.3 {test !dir, no variable} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path d] $x]
    removeFile x
    set res
} {0 PRE}

test test-5.1.4 {test !dir, no label} {
    set path [makeFile {} x]

    set x PRE
    set res [list [fileutil::test $path d x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Is not a directory"]

test test-6.1.0 {test exec} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 1

    set x PRE
    set res [list [fileutil::test $path x x TEST] $x]
    removeFile x
    set res
} {1 PRE}

test test-6.1.1 {test exec, no variable} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 1

    set x PRE
    set res [list [fileutil::test $path x] $x]
    removeFile x
    set res
} {1 PRE}

test test-6.1.2 {test !exec} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path x x TEST] $x]
    removeFile x
    set res
} [list 0 "TEST \"$xpath\": Is not executable"]

test test-6.1.3 {test !exec, no variable} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path x] $x]
    removeFile x
    set res
} {0 PRE}

test test-6.1.4 {test !exec, no label} {unixOnly} {
    set path [makeFile {} x]
    makeexecutable $path 0

    set x PRE
    set res [list [fileutil::test $path x x] $x]
    removeFile x
    set res
} [list 0 "\"$xpath\": Is not executable"]

unset xpath

# -------------------------------------------------------------------------

test foreachline-1.0 {foreachLine} {
    set path [makeFile "foo\nbar\nbaz\n" {cat [1]}]

    set res ""
    ::fileutil::foreachLine line $path {
	append res /$line
    }

    removeFile {cat [1]}
    set res
} {/foo/bar/baz}


makeDirectory touchTest
makeFile "blah" [file join touchTest {file [1]}]

test touch-1.1 {create file} tcl8.3plus {
    set f [file join $dir touchTest here]
    fileutil::touch $f
    # reap this file on cleanup
    lappend ::tcltest::filesmade $f
    file exists $f
} 1

test touch-1.2 {'-c' prevents file creation} tcl8.3plus {
    set f [file join $dir touchTest nothere]
    fileutil::touch -c $f
    file exists $f
} 0

test touch-1.3 {'-c' has no effect on existing files} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch -c $f
    file exists $f
} 1

test touch-1.4 {test relative times} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    after 1001
    fileutil::touch $f
    set a2 [file atime $f]
    set m2 [file mtime $f]
    list [expr {$a1 == $m1}] [expr {$a2 == $m2}] [expr {$a1 < $a2}] [expr {$m1 < $m2}]
} [list 1 1 1 1]

test touch-1.5 {test relative times using -a} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    after 1001
    fileutil::touch -a $f
    set a2 [file atime $f]
    set m2 [file mtime $f]
    list [expr {$a1 == $m1}] [expr {$a2 == $m2}] [expr {$a1 < $a2}] [expr {$m1 < $m2}]
} [list 1 0 1 0]

test touch-1.6 {test relative times using -m} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    after 1001
    fileutil::touch -m $f
    set a2 [file atime $f]
    set m2 [file mtime $f]
    list [expr {$a1 == $m1}] [expr {$a2 == $m2}] [expr {$a1 < $a2}] [expr {$m1 < $m2}]
} [list 1 0 0 1]

test touch-1.7 {test relative times using -a and -m} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    after 1001
    fileutil::touch -a -m $f
    set a2 [file atime $f]
    set m2 [file mtime $f]
    list [expr {$a1 == $m1}] [expr {$a2 == $m2}] [expr {$a1 < $a2}] [expr {$m1 < $m2}]
} [list 1 1 1 1]

test touch-1.8 {test -t} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -t 42 $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == 42}] [expr {$m1 == 42}]
} [list 1 1]

test touch-1.9 {test -t with -a} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -t 42 -a $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == 42}] [expr {$m1 == 42}]
} [list 1 0]

test touch-1.10 {test -t with -m} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -t 42 -m $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == 42}] [expr {$m1 == 42}]
} [list 0 1]

test touch-1.11 {test -t with -a and -m} tcl8.3plus {
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -t 42 -a -m $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == 42}] [expr {$m1 == 42}]
} [list 1 1]

test touch-1.12 {test -r} tcl8.3plus {
    set r [info script]
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -r $r $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == [file atime $r]}] [expr {$m1 == [file mtime $r]}]
} [list 1 1]

test touch-1.13 {test -r with -a} tcl8.3plus {
    set r [info script]
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -r $r -a $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == [file atime $r]}] [expr {$m1 == [file mtime $r]}]
} [list 1 0]

test touch-1.14 {test -r with -m} tcl8.3plus {
    set r [info script]
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -r $r -m $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == [file atime $r]}] [expr {$m1 == [file mtime $r]}]
} [list 0 1]

test touch-1.15 {test -r with -a and -m} tcl8.3plus {
    set r [info script]
    set f [file join $dir touchTest {file [1]}]
    fileutil::touch $f
    after 1001
    fileutil::touch -r $r -m -a $f
    set a1 [file atime $f]
    set m1 [file mtime $f]
    list [expr {$a1 == [file atime $r]}] [expr {$m1 == [file mtime $r]}]
} [list 1 1]


set path [makeFile {} bogus]
removeFile bogus

test fileType-1.1 {test file non-existance} {
    set res [catch {fileutil::fileType $path} msg]
    list $res $msg
} [list 1 "file not found: '$path'"]
test fileType-1.2 {test file directory} {
    set f [makeDirectory fileTypeTest]
    set res [catch {fileutil::fileType $f} msg]
    removeDirectory fileTypeTest
    list $res $msg
} [list 0 [list directory]]
test fileType-1.3 {test file empty} {
    set f [makeEmptyFile]
    set res [catch {fileutil::fileType $f} msg]
    removeEmptyFile
    list $res $msg
} [list 0 [list empty]]
test fileType-1.4 {test simple binary} {
    set f [makeBinFile]
    set res [catch {fileutil::fileType $f} msg]
    removeBinFile
    list $res $msg
} [list 0 [list binary]]
test fileType-1.5 {test elf executable} {
    set f [makeElfFile]
    set res [catch {fileutil::fileType $f} msg]
    removeElfFile
    list $res $msg
} [list 0 [list binary executable elf]]
test fileType-1.6 {test simple text} {
    set f [makeTextFile]
    set res [catch {fileutil::fileType $f} msg]
    removeTextFile
    list $res $msg
} [list 0 [list text]]
test fileType-1.7 {test script file} {
    set f [makeScriptFile]
    set res [catch {fileutil::fileType $f} msg]
    removeScriptFile
    list $res $msg
} [list 0 [list text script /bin/tclsh]]
test fileType-1.8 {test html text} {
    set f [makeHtmlFile]
    set res [catch {fileutil::fileType $f} msg]
    removeHtmlFile
    list $res $msg
} [list 0 [list text html]]
test fileType-1.9 {test xml text} {
    set f [makeXmlFile]
    set res [catch {fileutil::fileType $f} msg]
    removeXmlFile
    list $res $msg
} [list 0 [list text xml]]
test fileType-1.10 {test xml with dtd text} {
    set f [makeXmlDTDFile]
    set res [catch {fileutil::fileType $f} msg]
    removeXmlDTDFile
    list $res $msg
} [list 0 [list text xml foobar]]
test fileType-1.11 {test PGP message} {
    set f [makePGPFile]
    set res [catch {fileutil::fileType $f} msg]
    removePGPFile
    list $res $msg
} [list 0 [list text message pgp]]
test fileType-1.12 {test binary graphic jpeg} {
    set f [makeJpegFile]
    set res [catch {fileutil::fileType $f} msg]
    removeJpegFile
    list $res $msg
} [list 0 [list binary graphic jpeg jfif]]
test fileType-1.13 {test binary graphic gif} {
    set f [makeGifFile]
    set res [catch {fileutil::fileType $f} msg]
    removeGifFile
    list $res $msg
} [list 0 [list binary graphic gif]]
test fileType-1.14 {test binary graphic png} {
    set f [makePngFile]
    set res [catch {fileutil::fileType $f} msg]
    removePngFile
    list $res $msg
} [list 0 [list binary graphic png]]
test fileType-1.15 {test binary graphic tiff} {
    set f [makeTiffFile]
    set res [catch {fileutil::fileType $f} msg]
    removeTiffFile
    list $res $msg
} [list 0 [list binary graphic tiff]]
test fileType-1.16 {test binary pdf} {
    set f [makePdfFile]
    set res [catch {fileutil::fileType $f} msg]
    removePdfFile
    list $res $msg
} [list 0 [list binary pdf]]
test fileType-1.17 {test text ps} {
    set f [makePSFile]
    set res [catch {fileutil::fileType $f} msg]
    removePSFile
    list $res $msg
} [list 0 [list text ps eps]]
test fileType-1.18 {test text eps} {
    set f [makeEPSFile]
    set res [catch {fileutil::fileType $f} msg]
    removeEPSFile
    list $res $msg
} [list 0 [list text ps eps]]
test fileType-1.19 {test binary gravity_wave_data_frame} {
    set f [makeIgwdFile]
    set res [catch {fileutil::fileType $f} msg]
    removeIgwdFile
    list $res $msg
} [list 0 [list binary gravity_wave_data_frame]]
test fileType-1.20 {test binary compressed bzip} {
    set f [makeBzipFile]
    set res [catch {fileutil::fileType $f} msg]
    removeBzipFile
    list $res $msg
} [list 0 [list binary compressed bzip]]
test fileType-1.21 {test binary compressed gzip} {
    set f [makeGzipFile]
    set res [catch {fileutil::fileType $f} msg]
    removeGzipFile
    list $res $msg
} [list 0 [list binary compressed gzip]]



# stripPwd/N/Prefix -----------------------------------------------------
# dir = $::tcltest::temporaryDirectory = current working directory

test stripPwd-1.0 {unrelated path} {
    fileutil::stripPwd {find 1}
} {find 1}

test stripPwd-1.1 {pwd-relative path} {
    fileutil::stripPwd [file join [pwd] $dir {find 1}]
} {find 1}

test stripPwd-1.2 {pwd-relative path} {
    fileutil::stripPwd [file join [pwd] $dir {find 1} {find 2}]
} [file join {find 1} {find 2}]

test stripPwd-1.3 {pwd itself} {
    fileutil::stripPwd [pwd]
} .


test stripPath-1.0 {unrelated path} {
    fileutil::stripPath [pwd] {find 1}
} {find 1}

test stripPath-1.1 {prefix-relative path} {
    fileutil::stripPath [pwd] [file join [pwd] $dir {find 1}]
} {find 1}

test stripPath-1.2 {prefix-relative path} {
    fileutil::stripPath [pwd] [file join [pwd] $dir {find 1} {find 2}]
} [file join {find 1} {find 2}]

test stripPath-1.3 {prefix itself} {
    fileutil::stripPath [pwd] [pwd]
} .


test stripN-1.0 {remove nothing} {
    fileutil::stripN {find 1} 0
} {find 1}

test stripN-1.1 {remove all} {
    fileutil::stripN {find 1} 1
} {}

test stripN-1.2 {remove more than existing} {
    fileutil::stripN {find 1} 2
} {}

test stripN-2.0 {remove nothing} {
    fileutil::stripN [file join {find 1} {find 2}] 0
} [file join {find 1} {find 2}]

test stripN-2.1 {remove part} {
    fileutil::stripN [file join {find 1} {find 2}] 1
} {find 2}

test stripN-2.2 {remove all} {
    fileutil::stripN [file join {find 1} {find 2}] 2
} {}

test stripN-2.3 {remove more than existing} {
    fileutil::stripN [file join {find 1} {find 2}] 3
} {}


# ----------------------------------------------------------------

# install --------------------------------------------------------

makeDirectory installDst
makeDirectory installSrc
makeDirectory [file join installSrc subdir]
makeFile "blah" [file join installSrc {file [1]}]

# Make a second subdirectory to install.
if { $tcl_platform(platform) == "unix" } {
    makeDirectory [file join installSrc subdir2]
    makeFile "blah" [file join installSrc subdir subfile1]
    makeFile "blah" [file join installSrc subdir subfile2]
    makeFile "blah" [file join installSrc subdir subfile3]

    foreach fl {1 2 3} {
	set fn [file join installSrc subdir2 subfile$fl]
	makeFile "blah" $fn

	# Give it some "bad" permissions.
	file attributes $fn -permissions 0600
    }
}

test install-1.1 {install a file} {
    fileutil::install [file join installSrc {file [1]}] installDst
    file exists [file join installDst {file [1]}]
} {1}

makeDirectory installDst
test install-2.1 {install a directory} {tcl8.4plus} {
    list [catch {
        fileutil::install [file join installSrc subdir] installDst
        set result [lsort [glob -tails -directory [file join installDst subdir] [file join . / *]]]
        file delete -force installDst
        set result
    } err] $err
} {0 {subfile1 subfile2 subfile3}}

makeDirectory installDst
test install-2.2 {install a directory} {tcl8.3plus} {
    list [catch {
        fileutil::install [file join installSrc subdir] installDst
        set result [lsort [glob -directory [file join installDst subdir] [file join . / *]]]
        file delete -force installDst
        set result
    } err] $err
} {0 {installDst/subdir/subfile1 installDst/subdir/subfile2 installDst/subdir/subfile3}}

makeDirectory installDst
test install-3.1 {install a directory, set permissions} {unix tcl8.3plus} {
    set res {}
    fileutil::install -m go+rw [file join installSrc subdir2] installDst
    foreach fl [glob [file join installDst subdir2 *]] {
	append res [file attributes $fl -permissions]
    }
    set res
} {006660066600666}

# -------------------------------------------------------------------------

test tempdir-1.1 {return the correct directorary for temporary files} {unix} {
    set ::env(TMPDIR) [pwd] ;# Most high-priority source, and existing directory!
    set result [::fileutil::tempdir]
    unset ::env(TMPDIR)
    set result
} [pwd]

test tempdir-1.2 {return the correct directorary for temporary files} {unix} {
    catch {unset ::env(TMPDIR)}
    catch {unset ::env(TEMPDIR)}
    catch {unset ::env(TMP)}
    catch {unset ::env(TEMP)}
    ::fileutil::tempdir
} {/tmp}

test tempfile-1.1 {generate temporary file name and file} {
    set filename [::fileutil::tempfile]
    set result [file exists $filename]
    file delete $filename
    set result
} {1}

test tempfile-1.2 {generate writable temporary file name} {
    set filename [::fileutil::tempfile]
    set result [file writable $filename]
    file delete $filename
    set result
} {1}

test tempfile-1.3 {generate 100 unique temporary filenames} {
    set filenames [list]
    for {set i 0} {$i<100} {incr i} {
	lappend filenames [::fileutil::tempfile]
    }
    foreach f $filenames {
	file delete $f
    }
    set i
} {100}

# -------------------------------------------------------------------------
# Set an exclusive directory to search. This cannot be unset, hence
# the location of these tests after the regular tempdir/tempfile
# tests.

removeDirectory x
set xpath [makeDirectory x]
removeDirectory x

test tempdir-1.3 {tempdir, user-specified, bad} {
    catch {::fileutil::tempdir x y} msg
    set msg
} {wrong#args: should be "::fileutil::tempdir ?path?"}

test tempdir-1.4 {tempdir, user-specified, bad} {
    set path [makeDirectory x]
    removeDirectory x
    ::fileutil::tempdir $path

    catch {::fileutil::tempdir} msg
    set msg
} {Unable to determine a proper directory for temporary files}

test tempdir-1.5 {tempdir, user-specified, ok} {
    set path [makeDirectory x]
    ::fileutil::tempdir $path

    set res [::fileutil::tempdir]
    removeDirectory x
    set res
} $xpath

test tempfile-1.4 {temp file in user specified directory} {
    set path [makeDirectory x]
    ::fileutil::tempdir $path

    set          filename [::fileutil::tempfile TEST]
    file delete $filename

    removeDirectory x
    string match $path/TEST* $filename
} 1

unset xpath

# -------------------------------------------------------------------------

test jail-1.0 {jail error} {
    catch {::fileutil::jail} res
    set res
} [tcltest::wrongNumArgs {::fileutil::jail} {jail filename} 0]

test jail-1.2 {jail error} {
    catch {::fileutil::jail a} res
    set res
} [tcltest::wrongNumArgs {::fileutil::jail} {jail filename} 1]

test jail-1.3 {jail error} {
    catch {::fileutil::jail a b c} res
    set res
} [tcltest::tooManyArgs {::fileutil::jail} {jail filename}]

test jail-2.0 {jail relative} {
    ::fileutil::jail /var/www a/b/c
} /var/www/a/b/c

test jail-2.1 {jail absolute outside} {
    ::fileutil::jail /var/www /a/b/c
} /var/www/a/b/c

test jail-2.1.1 {jail absolute outside, spaces} {
    ::fileutil::jail /var/www {/a/b/c d}
} {/var/www/a/b/c d}

test jail-2.2 {jail absolute inside} {
    ::fileutil::jail /var/www /var/www/a/b/c
} /var/www/a/b/c

test jail-2.2.1 {jail absolute inside} {
    ::fileutil::jail /var/www {/var/www/a/b/c d}
} {/var/www/a/b/c d}

test jail-2.3 {try to escape from jail} {
    ::fileutil::jail /var/www ../../etc/passwd
} /var/www/etc/passwd

test jail-2.4 {jail is relative itself} {
    ::fileutil::jail a b
} [file join $dir a b]

test jail-2.4.1 {jail is relative itself, spaces in path} {
    ::fileutil::jail a {b c}
} [file join $dir a {b c}]

test jail-2.4.2 {jail is relative itself, spaces in path} {
    ::fileutil::jail {a b} {c d}
} [file join $dir {a b} {c d}]



# Need tests using non-existing paths for sure. 
# Similar tests for 'normalize' as well.


## Tests for the internal 'Normalize' command.
##
## This is our forward compatibility wrapper and it should behave
## identical to the 8.4. builtin 'file normalize'.  We pilfered the
## test cases from the test suite for 'file normalize' in the Tcl
## core.

if {![string equal $::tcl_platform(platform) windows]} {

    set dirfile    [makeDirectory dir.file]
    set dirbfile   [makeDirectory dir2.file]
    set insidefile [makeFile "test file in directory" dir.file/inside.file]
    set gorpfile   [makeFile "test file" gorp.file]

    # Paths for the links.

    set linkfile       [tempPath link.file]
    set dirlink        [tempPath dir.link]
    set dirblink       [tempPath dir2.link]
    set linkinsidefile [tempPath $dirfile/linkinside.file]
    set dirbblink      [tempPath $dirbfile/dir2.link]]

    # Create the links. Unix specific.

    exec ln -s gorp.file    $linkfile
    exec ln -s inside.file  $linkinsidefile
    exec ln -s dir.file     $dirlink
    exec ln -s dir.link     $dirblink
    exec ln -s ../dir2.link $dirbblink

    # File/Directory structure created by the above.
    #
    #    /FOO/dir2.link -> dir.link
    #    /FOO/dir.link  -> dir.file
    #    /FOO/dir.file/
    #    /FOO/dir.file/linkinside.file -> inside.file
    #    /FOO/dir.file/inside.file
    #
    #    /FOO/link.file -> gorp.file
    #    /FOO/gorp.file
    #
    #    /FOO/dir2.file/
    #    /FOO/dir2.file/dir2.link -> ../dir2.link
}


test fu-normalize-1.0 {link normalisation} {unixOnly} {
    # Symlink of last path element is not resolved.
    string equal \
	    [::fileutil::Normalize $gorpfile] \
	    [::fileutil::Normalize $linkfile]
} {0}

test fu-normalize-1.1 {link normalisation} {unixOnly} {
    # Symlink of last path element is not resolved.
    string equal \
	    [::fileutil::Normalize $dirfile] \
	    [::fileutil::Normalize $dirlink]
} {0}

test fu-normalize-1.2 {link normalisation} {unixOnly} {
    # Link higher in path is resolved (File!, non-existing last component).
    string equal \
	    [::fileutil::Normalize [file join $gorpfile foo]] \
	    [::fileutil::Normalize [file join $linkfile foo]]
} {1}

test fu-normalize-1.3 {link normalisation} {unixOnly} {
    # Link higher in path is resolved (Directory, non-existing last component).
    string equal \
	    [::fileutil::Normalize [file join $dirfile foo]] \
	    [::fileutil::Normalize [file join $dirlink foo]]
} {1}

test fu-normalize-1.4 {link normalisation} {unixOnly} {
    # Link higher in path is resolved (Directory, existing last component).
    string equal \
	    [::fileutil::Normalize [file join $insidefile]] \
	    [::fileutil::Normalize [file join $dirlink inside.file]]
} {1}

test fu-normalize-1.5 {link normalisation} {unixOnly} {
    # Identical paths.
    string equal \
	    [::fileutil::Normalize [file join $linkinsidefile]] \
	    [::fileutil::Normalize [file join $linkinsidefile]]
} {1}

test fu-normalize-1.6 {link normalisation} {unixOnly} {
    # Double link, one in last component, that one not resolved.
    string equal \
	    [::fileutil::Normalize [file join $linkinsidefile]] \
	    [::fileutil::Normalize [file join $dirlink inside.file]]
} {0}

test fu-normalize-1.7 {link normalisation} {unixOnly} {
    # Double link, both higher up, second is file!, both resolved
    string equal \
	    [::fileutil::Normalize [file join $dirlink linkinside.file foo]] \
	    [::fileutil::Normalize [file join $insidefile foo]]
} {1}

test fu-normalize-1.8 {link normalisation} {unixOnly} {
    # Directory link, and bad last component
    string equal \
	    [::fileutil::Normalize [file join ${linkinsidefile}foo]] \
	    [::fileutil::Normalize [file join $dirlink inside.filefoo]]
} {0}

if 0 {
    test fu-normalize-1.9 {link normalisation} {unixOnly} {
	file delete -force $dirlink
	file link $dirlink [file nativename $dirfile]
	string equal \
		[::fileutil::Normalize [file join $linkinsidefile foo]] \
		[::fileutil::Normalize [file join $dirlink inside.file foo]]
    } {1}
}

test fu-normalize-1.10 {link normalisation: double link} {unixOnly} {
    # Double symlink in one component.
    string equal \
	    [::fileutil::Normalize [file join $linkinsidefile foo]] \
	    [::fileutil::Normalize [file join $dirblink inside.file foo]]
} {1}


test fu-normalize-1.11 {link normalisation: double link, back in tree} {unixOnly} {
    # Double link and back up in the tree.

    string equal \
	    [::fileutil::Normalize [file join $linkinsidefile foo]] \
	    [::fileutil::Normalize [file join $dirbblink inside.file foo]]
} {1}


test fu-normalize-2.0 {normalisation, non-existing paths} {unixOnly} {
    ::fileutil::Normalize /a/b/c
} /a/b/c

test fu-normalize-2.1 {normalisation, non-existing paths} {unixOnly} {
    ::fileutil::Normalize /a/../b/c
} /b/c

test fu-normalize-2.2 {normalisation, non-existing paths} {unixOnly} {
    ::fileutil::Normalize /a/./b/c
} /a/b/c

test fu-normalize-2.3 {normalisation, non-existing paths} {unixOnly} {
    ::fileutil::Normalize /../b/c
} /b/c

test fu-normalize-2.4 {normalisation, non-existing paths} {unixOnly} {
    ::fileutil::Normalize /a/../../b/c
} /b/c


removeFile      find3/find4/file5
removeDirectory find3/find4
removeDirectory find3
removeDirectory touchTest
removeDirectory installDst
removeDirectory installSrc
removeDirectory {find 1}
removeDirectory dotfiles
removeDirectory grepTest

if {![string equal $::tcl_platform(platform) windows]} {
    file delete -force $linkfile
    file delete -force $dirlink
    file delete -force $dirblink
    file delete -force $linkinsidefile
    file delete -force $dirbblink

    removeFile dir.file/inside.file
    removeFile gorp.file
    removeDirectory dir.file
    removeDirectory dir2.file
}

# -------------------------------------------------------------------------
# Computation of paths relative to a base.


test fu-relative-1.0 {fileutil::relative, wrong#args} {
    catch {fileutil::relative} msg
    set msg
} [tcltest::wrongNumArgs fileutil::relative {base dst} 0]

test fu-relative-1.1 {fileutil::relative, wrong#args} {
    catch {fileutil::relative a} msg
    set msg
} [tcltest::wrongNumArgs fileutil::relative {base dst} 1]

test fu-relative-1.2 {fileutil::relative, wrong#args} {
    catch {fileutil::relative a b c} msg
    set msg
} [tcltest::tooManyArgs fileutil::relative {base dst}]

foreach {n base dst result} {
    0  /base         /base/destination    destination
    1  /base         /destination         ../destination
    2   base          base/destination    destination
    3   base          destination         ../destination
    4  /sub/base     /sub/sub/destination ../sub/destination
    5  /sub/sub/base /sub/destination     ../../destination
    6   sub/base      sub/sub/destination ../sub/destination
    7   sub/sub/base  sub/destination     ../../destination
    8  /base         /base                .
    9   base          base                .
    10 /base/sub     /base/sub            .
    11  base/sub      base/sub            .
    12 /base/sub     /base                ..
    13  base/sub      base                ..
} {
    test fu-relative-2.$n {fileutil::relative} {
	fileutil::relative $base $dst
    } $result
}

foreach {n base dst ra rb} {
    0 /base          base/destination absolute relative
    1  base         /destination      relative absolute
} {
    test fu-relative-3.$n {fileutil::relative, bad mix} {
	catch {fileutil::relative $base $dst} msg
	set msg
    } "Unable to compute relation for paths of different pathtypes: $ra vs. $rb"
}


test fu-relativeurl-1.0 {fileutil::relativeUrl, wrong#args} {
    catch {fileutil::relativeUrl} msg
    set msg
} [tcltest::wrongNumArgs fileutil::relativeUrl {base dst} 0]

test fu-relativeurl-1.1 {fileutil::relativeUrl, wrong#args} {
    catch {fileutil::relativeUrl a} msg
    set msg
} [tcltest::wrongNumArgs fileutil::relativeUrl {base dst} 1]

test fu-relativeurl-1.2 {fileutil::relativeUrl, wrong#args} {
    catch {fileutil::relativeUrl a b c} msg
    set msg
} [tcltest::tooManyArgs fileutil::relativeUrl {base dst}]

foreach {n base dst result} {
    0  /base/file.html         /base/destination/xx.html    destination/xx.html
    1  /base/file.html         /destination/xx.html         ../destination/xx.html
    2   base/file.html          base/destination/xx.html    destination/xx.html
    3   base/file.html          destination/xx.html         ../destination/xx.html
    4  /sub/base/file.html     /sub/sub/destination/xx.html ../sub/destination/xx.html
    5  /sub/sub/base/file.html /sub/destination/xx.html     ../../destination/xx.html
    6   sub/base/file.html      sub/sub/destination/xx.html ../sub/destination/xx.html
    7   sub/sub/base/file.html  sub/destination/xx.html     ../../destination/xx.html
    8  /base/file.html         /base/xx.html                xx.html
    9   base/file.html          base/xx.html                xx.html
    10 /base/sub/file.html     /base/sub/xx.html            xx.html
    11  base/sub/file.html      base/sub/xx.html            xx.html
    12 /base/sub/file.html     /base/xx.html                ../xx.html
    13  base/sub/file.html      base/xx.html                ../xx.html
} {
    test fu-relativeurl-2.$n {fileutil::relativeUrl} {
	fileutil::relativeUrl $base $dst
    } $result
}

foreach {n base dst ra rb} {
    0 /base/file.html          base/destination/xx.html absolute relative
    1  base/file.html         /destination/xx.html      relative absolute
} {
    test fu-relativeurl-3.$n {fileutil::relativeUrl, bad mix} {
	catch {fileutil::relativeUrl $base $dst} msg
	set msg
    } "Unable to compute relation for paths of different pathtypes: $ra vs. $rb"
}


# -------------------------------------------------------------------------
# Restore "env" array to the state it had at the beginning of the testsuite.

#array unset env * - 8.4+, package is 8.2+
foreach k [array names env] {unset env($k)}
array set env $oldenv

::tcltest::cleanupTests
return
