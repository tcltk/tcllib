[vset VERSION 2.6.1]
[manpage_begin base64 n [vset VERSION]]
[keywords base64]
[keywords encoding]
[copyright {2000, Eric Melski}]
[copyright {2001, Miguel Sofer}]
[moddesc   {Text encoding & decoding binary data}]
[titledesc {base64-encode/decode binary data}]
[category  {Text processing}]
[require Tcl "8.5 9"]
[require base64 [opt [vset VERSION]]]
[description]
[para]

This package provides commands for encoding and decoding binary strings
to and from the standard base64 encoding as specified in
[uri https://datatracker.ietf.org/doc/html/rfc4648 {RFC 4648}].

[para]
[emph {It is recommended that for new code the built-in}] [cmd binary]
[emph {subcommands for encoding and decoding base64 (introduced in Tcl
8.6), are used in preference to this package’s commands.}]

[section {Beware: Variations in decoding behaviour}]

Tcl 8.6 introduced built-in support for encoding and decoding base64
using subcommands of the [cmd binary] command: 

[example {
    binary encode base64
    binary decode base64
}]

[para] Beware that although these subcommands have the same signatures
as the commands provided by this package, the decoders are
[emph {not behaviourally compatible}].

[para] The built-in [cmd {binary decode base64}] subcommand accepts the
option [option -strict], enabling the user to choose between strict and
nonstrict modes. In strict mode invalid characters, and partial data at
the end of the input are reported as errors. In nonstrict mode they are
ignored. (See [uri https://www.rfc-editor.org/rfc/rfc2045#section-6.8 \
{RFC 2045}].)

[para] The implementations provided by this package do not offer control
over strictness. Instead they mix strict and nonstrict. Partial data at
the end of the input is reported as an error, but invalid characters are
ignored.

[para]
By default this package’s encoder wraps using newlines after every 76
characters of output. The built-in [cmd {binary encode base64}]
subcommand defaults to not wrapping, but does support wrapping using a
[option -maxlen] option.

[section API]

[list_begin definitions]

[call [cmd ::base64::encode] [opt "[option -maxlen] [arg maxlen]"] \
[opt "[option -wrapchar] [arg wrapchar]"] [arg bstring]]

Returns a base64-encoded version of the binary string [arg bstring] as
its result.

[para]
The result string contains the [arg wrapchar] character after every
[arg maxlen] characters of output. The [arg wrapchar] defaults to
newline and [arg maxlen] defaults to 76. To prevent wrapping, set
[arg maxlen] to [const 0].

[para]
The command will throw an error if [arg maxlen] is not an integer or is
negative, or if [arg bstring] is neither a binary string, nor a string
containing only 7-bit ASCII.

[call [cmd ::base64::decode] [arg estring]]

Returns a binary string that has been base64-decoded from the
[arg estring]. Any invalid characters or whitespace (spaces, tabs,
newlines) in [arg estring] are ignored.

[list_end]

[section {Implementation Notes}]

This package contains three different implementations for base64
encoding and decoding, and chooses among them based on the environment
it finds itself in.

[para] All three implementations have the same behaviour.

See also [sectref {Beware: Variations in decoding behaviour}] at the
beginning of this document.

[list_begin enumerated]

[enum]  If Tcl 8.6 or higher is found the commands are implemented in
	terms of the then-available builtin commands.

[enum]  If the [package Trf] extension can be loaded the commands are
	implemented in terms of its commands.

[enum]  If neither of the above are possible a Tcl-only implementation
	is used. This is much slower.

[list_end]

[section {EXAMPLES}]

This example shows how to encode and decode a Tcl string to and from
base64, taking account of the fact that the base64 commands work in
terms of binary strings.

[example {
const UTF8_LINE "Δ÷ “Utf-8” ♞ℤ"
# Legacy (this package)
set bytes [encoding convertto utf-8 $UTF8_LINE]
set enc64 [::base64::encode $bytes]
set dec64 [::base64::decode $enc64]
set line [encoding convertfrom utf-8 $dec64]
puts "base64='$enc64' [expr {$UTF8_LINE eq $line}]"
=>
base64='zpTDtyDigJxVdGYtOOKAnSDimZ7ihKQ=' 1
# Modern (using built-in binary subcommands)
set bytes [encoding convertto utf-8 $UTF8_LINE]
set enc64 [binary encode base64 $bytes]
set dec64 [binary decode base64 $enc64]
set line [encoding convertfrom utf-8 $dec64]
puts "base64='$enc64' [expr {$UTF8_LINE eq $line}]"
=>
base64='zpTDtyDigJxVdGYtOOKAnSDimZ7ihKQ=' 1
}]

If the original string is 7-bit ASCII the conversions to and from raw
bytes using the built-in [cmd encoding] command are not needed. For example:

[example {
const ASCII_LINE "! 7-bit ASCII {~^}"
# Legacy (this package)
set enc64 [::base64::encode $ASCII_LINE]
set dec64 [::base64::decode $enc64]
set line [encoding convertfrom utf-8 $dec64]
puts "base64='$enc64' [expr {$ASCII_LINE eq $line}]"
=> 
base64='ISA3LWJpdCBBU0NJSSB7fl59' 1
# Modern (using built-in binary subcommands)
set enc64 [binary encode base64 $ASCII_LINE]
set dec64 [binary decode base64 $enc64]
set line [encoding convertfrom utf-8 $dec64]
puts "base64='$enc64' [expr {$ASCII_LINE eq $line}]"
=> 
base64='ISA3LWJpdCBBU0NJSSB7fl59' 1
}]

Wrapping can be prevented so that no whitespace is introduced:

[example {
base64::encode [string repeat xyz 20]
=>
eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6
eHl6eHl6eHl6
base64::encode -maxlen 0 [string repeat xyz 20]
=>
eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6eHl6
}]

[para]
Note that the built-in [cmd {binary encode base64}] subcommand defaults
to not wrapping, but will wrap if the [option -maxlen] option is used.

[vset CATEGORY base64]
[include ../common-text/feedback.inc]
[manpage_end]
