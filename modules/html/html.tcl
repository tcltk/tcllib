# html.tcl --
#
#	Procedures to make generating HTML easier.
#
#	This module depends on the ncgi module for the procedures
#	that initialize form elements based on current CGI values.
#
# Copyright (c) 1998-2000 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: html.tcl,v 1.1 2000/04/18 01:26:38 welch Exp $

package provide html 1.0

namespace eval html:: {

    # State about the current page

    variable page

    # Default values

    variable defaults
    array set defaults {
	fieldWidth	45
	textareaHeight	8
	bgcolor		white
	text		black
    }

    namespace export *
}

# html::reset
#
#	Reset state that gets accumulated for the current page.
#
# Arguments:
#	args:	Name, value list that is used to initialize default namespace
#		variables that set font, size, etc.
#
# Side Effects:
#	Wipes the page state array

proc html::reset {args} {
    variable page
    variable defaults
    if {[info exist page]} {
	unset page
    }
    array set defaults $args
}

# html::head
#
#	Generate the <head> section.  There are a number of
#	optional calls you make *before* this to inject
#	meta tags - see everything between here and the bodytag proc.
#
# Arguments:
#	title	The page title
#
# Results:
#	HTML for the <head> section

proc html::head {title} {
    variable page
    set html "<html><head>"
    append html "\t[html::title $title]\n"
    foreach item {author keywords meta description} {
	if {[info exist page($item)]} {
	    append html "\t$page($item)\n"
	}
    }
    append html "</head>\n"
}

# html::title
#
#	Wrap up the <title> and tuck it away for use in the page later.
#
# Arguments:
#	title	The page title
#
# Results:
#	HTML for the <title> section

proc html::title {title} {
    variable page
    set page(title) $title
    set html "<title>$title</title>"
    return $html
}

# html::getTitle
#
#	Return the title of the current page.
#
# Arguments:
#	None
#
# Results:
#	The title

proc html::getTitle {} {
    variable page
    if {[info exist page(title)]} {
	return $page(title)
    } else {
	return ""
    }
}

# html::meta
#
#	Generate a meta tag.  This tag gets bundled into the <head>
#	section generated by html::head
#
# Arguments:
#	args	A name-value list of meta tag names and values.
#
# Side Effects:
#	Stores HTML for the <meta> tag for use later by html::head

proc html::meta {args} {
    variable page
    set html ""
    foreach {name value} $args {
	append html "<meta name=\"$name\" value=\"$value\">\n"
    }
    set page(meta) $html
    return ""
}

# html::keywords
#
#	Add META tag keywords to the <head> section.
#	Call this before you call html::head
#
# Arguments:
#	args	The keywords
#
# Side Effects:
#	Adds keywords to page(keywords)
#	We use page because it gets automatically reset by
#	the template processor for each page

proc html::keywords {args} {
    variable page

    set html "<meta name=keywords value=\"[join $args ", "]\">"
    set page(keywords) $html
    return ""
}

# html::author
#
#	Add an author comment to the <head> section.
#	Call this before you call html::head
#
# Arguments:
#	author	Author's name
#
# Side Effects:
#	sets page(author)
#	We use page because it gets automatically reset by
#	the template processor for each page

proc html::author {author} {
    variable page
    set page(author) "<!-- $author -->"
    return ""
}

# html::description
#
#	Add a description META tag to the <head> section.
#	Call this before you call html::head
#
# Arguments:
#	description	The description
#
# Side Effects:
#	sets page(description)
#	We use page because it gets automatically reset by
#	the template processor for each page

proc html::description {description} {
    variable page
    set page(description) \
	"<meta name=description value=\"$description\">"
    return ""
}

# html::bodytag
#
#	Generate a body tag
#
# Arguments:
#	none
#
# Results
#	A body tag

proc html::bodytag {} {
    variable default
    append html "<body"
    if {![html::varempty default(bgcolor)]} {
	append html " bgcolor=$default(bgcolor)"
    }
    if {![html::varempty default(text)]} {
	append html " text=$default(text)"
    }
    append html ">\n"
    return $html
}

# The following procedures are all related to generating form elements
# that are initialized to store the current value of the form element
# based on the CGI state.  These functions depend on the ncgi::value
# procedure and assume that the caller has called ncgi::parse and/or
# ncgi::reset appropriately to initialize the ncgi module.

# html::formvalue
#
#	Return a name and value pair, where the value is initialized
#	from existing form data, if any.
#
# Arguments:
#	name		The name of the form element
#	defvalue	A default value to use, if not appears in the CGI
#			inputs
#
# Retults:
#	A string like:
#	name="fred" value="freds value"

proc html::formvalue {name {defvalue {}}} {
    set value [ncgi::value $name]
    if {[string length $value] == 0} {
	set value $defvalue
    }
    regsub -all {"} $value {\&#34;} value
    regsub -all {'} $value {\&#39;} value
    regsub -all {<} $value {\&lt;} value
    regsub -all {>} $value {\&gt;} value
    return "name=\"$name\" value=\"[quoteformvalue $value]\""
}

# html::quoteformvalue
#
#	Quote a value for use in a value=\"$value\" fragment.
#
# Arguments:
#	value		The value to quote
#
# Retults:
#	A string like:
#	&#34;Hello, &lt;b&gt;World!&#34;

proc html::quoteformvalue {value} {
    regsub -all {&} $value {\&amp;} value
    regsub -all {"} $value {\&#34;} value
    regsub -all {'} $value {\&#39;} value
    regsub -all {<} $value {\&lt;} value
    regsub -all {>} $value {\&gt;} value
    return $value
}

# html::textinpupt --
#
#	Return an <input type=text> element.  This looks at the the
#	textwidth html variable.
#
# Arguments:
#	name	The form element name
#
# Results:
#	The html fragment

proc html::textinput {name {value {}}} {
    variable defaults
    set html "<input type=text [html::formvalue $name $value] [html::fieldWidth]"
    append html ">\n"
    return $html
}

# html::textinpupt --
#
#	Return an <input type=text> element.  This looks at the the
#	textwidth html variable.
#
# Arguments:
#	name	The form element name
#
# Results:
#	The html fragment

proc html::textinput {name {value {}}} {
    variable defaults
    set html "<input type=text [html::formvalue $name $value]"
    if {![html::varempty defaults(fieldWidth)]} {
	append html " size=$defaults(fieldWidth)"
    }
    append html ">\n"
    return $html
}

# html::passwordinpupt --
#
#	Return an <input type=password> element.  This looks at the the
#	textwidth html variable.
#
# Arguments:
#	name	The form element name
#
# Results:
#	The html fragment

proc html::passwordinput {name} {
    variable defaults
    set html "<input type=password"
    if {![html::varempty defaults(fieldWidth)]} {
	append html " size=$defaults(fieldWidth)"
    }
    append html ">\n"
    return $html
}

# html::checkbox --
#
#	Format a checkbox so that it retains its state based on
#	the current CGI values
#
# Arguments:
#	name		The form element name
#	value		The value associated with the checkbox
#
# Results:
#	The html fragment

proc html::checkbox {name value} {
    set html "<input type=checkbox [checkvalue $name $value]>\n"
}

# html::checkvalue
#
#	Like html::formalue, but for checkboxes that need CHECKED
#
# Arguments:
#	name		The name of the form element
#	defvalue	A default value to use, if not appears in the CGI
#			inputs
#
# Retults:
#	A string like:
#	name="fred" value="freds value" CHECKED


proc html::checkvalue {name {value 1}} {
    variable page
    foreach v [ncgi::valuelist $name] {
	if {[string compare $value $v] == 0} {
	    return "name=\"$name\" value=\"[quoteformvalue $value]\" CHECKED"
	}
    }
    return "name=$name value=\"[quoteformvalue $value]\""
}

# html::radiovalue
#
#	Like html::formalue, but for radioboxes that need CHECKED
#
# Arguments:
#	name	The name of the form element
#	value	The value associated with the radio button.
#
# Retults:
#	A string like:
#	name="fred" value="freds value" CHECKED

proc html::radiovalue {name value} {
    if {[string equal $value [ncgi::value $name]]} {
	return "name=$name value=\"[quoteformvalue $value]\" CHECKED"
    } else {
	return "name=$name value=\"[quoteformvalue $value]\""
    }
}

# html::radioset --
#
#	Display a set of radio buttons while looking for an existing
#	value from the query data, if any.

proc html::radioset {key sep list} {
    set html ""
    foreach {v label} $list {
	append html "<input type=radio [radiovalue $key $v]> $label$sep"
    }
    return $html
}

# html::checkset --
#
#	Display a set of check buttons while looking for an existing
#	value from the query data, if any.

proc html::checkset {key sep list} {
    variable page
    array set query $page(query)
    foreach {v label} $list {
	append html "<input type=checkbox [checkvalue $key $v]> $label$sep"
    }
    return $html
}


# html::selectplain --
#
#	Format a <select> element where the values are the same
#	as those that are displayed.
#
# Arguments:
#	name		The form element name
#	param		Tag parameters
#	choices		A simple list of choices
#
# Results:
#	The html fragment

proc html::selectplain {name param choices {current {}}} {
    set namevalue {}
    foreach c $choices {
	lappend namevalue $c $c
    }
    return [html::select $name $param $namevalue $current]
}

# html::select --
#
#	Format a <select> element that retains the state of the
#	current CGI values.
#
# Arguments:
#	name		The form element name
#	param		The various size, multiple parameters for the tag
#	choices		A simple list of choices
#	current		Value to assume if nothing is in CGI state
#
# Results:
#	The html fragment

proc html::select {name param choices {current {}}} {
    variable page

    set def [ncgi::value $name $current]
    set html "<select name=\"$name\" $param>\n"
    foreach {v label} $choices {
	if {[string equal $def $v]} {
	    set SEL SELECTED
	} else {
	    set SEL ""
	}
	append html "<option value=\"$v\" $SEL>$label\n"
    }
    append html "</select>\n"
    return $html
}

# html::textarea --
#
#	Format a <textarea> element that retains the state of the
#	current CGI values.
#
# Arguments:
#	name		The form element name
#	param		The various size, multiple parameters for the tag
#	current		Value to assume if nothing is in CGI state
#
# Results:
#	The html fragment

proc html::textarea {name {param {}} {current {}}} {
    set value [ncgi::value $name $current]
    set html "<textarea name=\"$name\" $param>$value</textarea>\n"
    return $html
}

# html::submit --
#
#	Format a submit button.
#
# Arguments:
#	label		The string to appear in the submit button.
#	name		The name for the submit button element
#
# Results:
#	The html fragment


proc html::submit {label {name submit}} {
    set html "<input type=submit name=\"$name\" value=\"$label\">\n"
}

# html::varempty --
#
#	Return true if the variable doesn't exist or is an empty string
#
# Arguments:
#	varname	Name of the variable
#
# Results:
#	1 if the variable doesn't exist or has the empty value

proc html::varempty {name} {
    upvar 1 $name var
    if {[info exist var]} {
	set value $var
    } else {
	set value ""
    }
    return [expr {[string length [string trim $value]] == 0}]
}

# html::getFormInfo --
#
#	Generate hidden fields to capture form values.
#
# Arguments:
#	args	List of elements to save.  If this is empty, everything is
#		saved in hidden fields.  This is a list of string match
#		patterns.
#
# Results:
#	A bunch of <input type=hidden> elements

proc html::getFormInfo {args} {
    if {[llength $args] == 0} {
	set args *
    }
    set html ""
    foreach {n v} [ncgi::nvlist] {
	foreach pat $args {
	    if {[string match $pat $n]} {
		append html "<input type=hidden name=\"$n\" \
				    value=\"[quoteformvalue $v]\">\n"
	    }
	}
    }
    return $html
}

# html::open
#	Remember that a tag  is opened so it can be closed later.
#	This is used to automatically clean up at the end of a page.
#
# Arguments:
#	tag	The HTML tag name
#	args	Any parameters for the tag
#
# Results:
#	Formats the tag.  Also keeps it around in a per-page stack
#	of open tags.

proc html::open {tag args} {
    variable page
    lappend page(stack) $tag
    return <[string trimright "$tag $args"]>
}

# html::close
#	Pop a tag from the stack and close it.
#
# Arguments:
#	None
#
# Results:
#	A close tag.  Also pops the stack.

proc html::close {} {
    variable page
    set top [lindex $page(stack) end]
    set page(stack) [lreplace $page(stack) end end]
    return </$top>
}

# html::end
#
#	Close out all the open tags.  Especially useful for
#	Tables that do not display at all if they are unclosed.
#
# Arguments:
#	None
#
# Results:
#	Some number of close HTML tags.

proc html::end {} {
    variable page
    set html ""
    while {[llength $page(stack)]} {
	append html [html::close]\n
    }
    return $html
}

# html::row
#
#	Format a table row.  If the default font has been set, this
#	takes care of wrapping the table cell contents in a font tag.
#
# Arguments:
#	args	Values to put into the row
#
# Results:
#	A <tr><td>...</tr> fragment

proc html::row {args} {
    set html <tr>\n
    foreach x $args {
	append html \t[html::cell "" $x td]\n
    }
    append html "</tr>\n"
    return $html
}

# html::hdrrow
#
#	Format a table row.  If the default font has been set, this
#	takes care of wrapping the table cell contents in a font tag.
#
# Arguments:
#	args	Values to put into the row
#
# Results:
#	A <tr><th>...</tr> fragment

proc html::hdrrow {args} {
    variable defaults
    set html <tr>\n
    foreach x $args {
	append html \t[html::cell "" $x th]\n
    }
    append html "</tr>\n"
    return $html
}

# html::cell
#
#	Format a table cell.  If the default font has been set, this
#	takes care of wrapping the table cell contents in a font tag.
#
# Arguments:
#	param	Td tag parameters
#	value	The value to put into the cell
#	tag	(option) defaults to TD
#
# Results:
#	<td>...</td> fragment

proc html::cell {param value {tag td}} {
    variable defaults
    if {![varempty defaults(fontface)] || ![varempty default(fontsize)]} {
	set value [html::font]$value</font>
    }
    return "<[string trimright "$tag $param"]>$value</$tag>"
}

# html::tableFromArray
#
#	Format a Tcl array into an HTML table
#
# Arguments:
#	arrname	The name of the array
#	pat	A string match pattern for the element keys
#
# Results:
#	A <table>

proc html::tableFromArray {arrname {pat *}} {
    upvar 1 $arrname arr
    set html ""
    if {[info exists arr]} {
	append html <TABLE>\n
	append html "<TR><TH colspan=2>$arrname</TH></TR>\n"
	foreach name [lsort [array names arr $pat]] {
	    append html [html::row $name $arr($name)]
	}
	append html </TABLE>\n
    }
    return $html
}

# html::tableFromList
#
#	Format a table from a name, value list
#
# Arguments:
#	querylist	A name, value list
#	param		The <table> tag parameters, if any.
#
# Results:
#	A <table>

proc html::tableFromList {querylist {param {}}} {
    set html ""
    if {[llength $querylist]} {
	append html "<TABLE $param>"
	foreach {label value} $querylist {
	    append html [html::row $label $value]
	}
	append html </TABLE>
    }
    return $html
}

# html::mailto
#
#	Format a mailto: HREF tag
#
# Arguments:
#	email	The target
#	subject	The subject of the email, if any
#
# Results:
#	A <a href=mailto> tag </a>

proc html::mailto {email {subject {}}} {
    set html "<a href=\"mailto:$email"
    if {[string length $subject]} {
	append html ?subject=$subject
    }
    append html "\">$email</a>"
    return $html
}

# html::font
#
#	Generate a standard <font> tag.  This depends on defaults being
#	set via html::reset
#
# Arguments:
#	args	Font parameters.  
#
# Results:
#	HTML

proc html::font {args} {
    variable defaults
    set param [join $args]
    if {![string match *font=* $param] && ![varempty defaults(fontface)]} {
	append param " font=\"$defaults(fontface)\""
    }
    if {![string match *size=* $param] && ![varempty defaults(fontsize)]} {
	append param " size=\"$defaults(fontsize)\""
    }
    return <[string trimright "font $param"]>
}

# html::formatcode
#
#	Format Tcl code for inclusion in HTML
#
# Arguments:
#	code	The code
#
# Results:
#	HTML

proc html::formatcode {code} {
    regsub -all {&} $code {\&amp;} code
    regsub -all {<} $code {\&lt;} code
    regsub -all {>} $code {\&gt;} code
    return "<PRE>$code</PRE>"
}

# html::minormenu
#
#	Create a menu of links given a list of label, URL pairs.
#	If the URL is the current page, it is not highlighted.
#
# Arguments:
#
#	list	List that alternates label, url, label, url
#	sep	Separator between elements
#
# Results:
#	html

proc html::minormenu {list {sep { | }}} {
    global page
    set s ""
    set html ""
    regsub {index.h?tml$} [ncgi::urlstub] {} this
    foreach {label url} $list {
	regsub {index.h?tml$} $url {} that
	if {[string compare $this $that] == 0} {
	    append html "$s$label"
	} else {
	    append html "$s<a href=\"$url\">$label</a>"
	}
	set s $sep
    }
    return $html
}
