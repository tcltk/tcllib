# -*- tcl -*-
# Tests for 1-d optimisation functions in math library  -*- tcl -*-
#
# This file contains a collection of tests for one or more of the Tcllib
# procedures.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# $Id: optimize.test,v 1.8 2005/08/09 07:37:18 arjenmarkus Exp $
#
# Copyright (c) 2004 by Arjen Markus
# Copyright (c) 2004 by Kevin B. Kenny
# All rights reserved.
#
# Note:
#    By evaluating the tests in a different namespace than global,
#    we assure that the namespace issue (Bug #...) is checked.
#

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.1
    namespace import ::tcltest::*
} else {
    # Ensure that 2.1 or higher present.

    if {![package vsatisfies [package present tcltest] 2.1]} {
	puts "Aborting tests for math::statistics."
	puts "Requiring tcltest 2.1, have [package present tcltest]"
	return
    }
}

source [file join [file dirname [info script]] optimize.tcl]

set ::tcl_precision 17

namespace eval optimizetest {

namespace import ::math::optimize::*

# Service procedure to develop the error message for "wrong # args"

proc wrongNumArgs {name arglist count} {
    # Use [package provide Tcl] instead of this buggy mess.
    #    set ver [info patchlevel]
    #    strip "a1", etc. designations
    #    regsub {(a|b)[1-9]$} $ver {} ver
    set ver [package provide Tcl]
    if {[package vcompare $ver 8.4] < 0} {
	set arg [lindex $arglist $count]
	set msg "no value given for parameter \"$arg\" to \"$name\""
    } else {
	set msg "wrong # args: should be \"$name $arglist\""
    }
    return $msg
}

#
# Simple test functions
#
proc const_func { x } {
   return 1.0
}
proc ffunc { x } {
   expr {$x*(1.0-$x*$x)}
}
proc minfunc { x } {
   expr {-$x*(1.0-$x*$x)}
}
proc absfunc { x } {
   expr {abs($x*(1.0-$x*$x))}
}

proc within_range { result min max } {
   #puts "Within range? $result $min $max"
   #puts "[expr {2.0*abs($result-$min)/abs($max+$min)}]"
   if { $result >= $min && $result <= $max } {
      set ok 1
   } else {
      set ok 0
   }
   return $ok
}

#
# Test the minimum procedure
#
# Note about the uneven and even functions:
# the initial interval is chosen symmetrical, so that the
# three function values are equal.
#
test optimize-1.1 "Minimum of constant function" {
   set result [minimum -1.0 1.0 ::optimizetest::const_func]
   within_range $result -1.0 1.0
} 1

test optimize-1.2 "Minimum of odd function, case 1" {
   set result [minimum -1.0 1.0 ::optimizetest::ffunc]
   set xmin   [expr {-sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {-sqrt(1.0/3.0)+0.0001}]
   within_range $result $xmin $xmax
} 1

test optimize-1.3 "Minimum of odd function, asymmetric interval" {
   set result [minimum -0.8 1.2 ::optimizetest::ffunc]
   set xmin   [expr {-sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {-sqrt(1.0/3.0)+0.0001}]
   within_range $result $xmin $xmax
} 1

test optimize-1.4 "Minimum of odd function, case 2" {
   set result [minimum -1.0 1.0 ::optimizetest::minfunc]
   set xmin   [expr {sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {sqrt(1.0/3.0)+0.0001}]
   within_range $result $xmin $xmax
} 1

test optimize-1.5 "Minimum of even function" {
   set result [minimum -1.0 1.0 ::optimizetest::absfunc]
   set xmin   -0.0001
   set xmax    0.0001
   within_range $result $xmin $xmax
} 1

#
# Test the maximum procedure
#
# Note about the uneven and even functions:
# the initial interval is chosen symmetrical, so that the
# three function values are equal.
#
test optimize-2.1 "Maximum of constant function" {
   set result [maximum -1.0 1.0 ::optimizetest::const_func]
   within_range $result -1.0 1.0
} 1

test optimize-2.2 "Maximum of odd function, case 1" {
   set result [maximum -1.0 1.0 ::optimizetest::ffunc]
   set xmin   [expr {sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {sqrt(1.0/3.0)+0.0001}]
   within_range $result $xmin $xmax
} 1

test optimize-2.3 "Maximum of odd function, case 2" {
   set result [maximum -1.0 1.0 ::optimizetest::minfunc]
   set xmin   [expr {-sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {-sqrt(1.0/3.0)+0.0001}]
   within_range $result $xmin $xmax
} 1

#
# Either of the two maxima will do
#
test optimize-2.4 "Maximum of even function" {
   set result [maximum -1.0 1.0 ::optimizetest::absfunc]
   set xmin   [expr {-sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {-sqrt(1.0/3.0)+0.0001}]
   set ok     [within_range $result $xmin $xmax]
   set xmin   [expr {sqrt(1.0/3.0)-0.0001}]
   set xmax   [expr {sqrt(1.0/3.0)+0.0001}]
   incr ok    [within_range $result $xmin $xmax]
} 1


# Custom match procedure for approximate results

proc withinEpsilon { shouldBe is } {
    expr { [string is double $is]
	   && abs( $is - $shouldBe ) < 1.e-07 * abs($shouldBe) }
}

::tcltest::customMatch withinEpsilon [namespace code withinEpsilon]

test linmin-1.1 {find minimum of a parabola - constrained} \
    -setup {
	proc f x { expr { ($x + 3.) * ($x - 1.) } }
    } \
    -body {
	foreach {x y} [min_bound_1d f 10. -10.] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result -1. \
    -match withinEpsilon

test linmin-1.2 {find minimum of cosine} \
    -setup {
	proc f x { expr { cos($x) } }
    } \
    -body {
	foreach { x y } [min_bound_1d f 0. 6.28318] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 3.1415926535897932 \
    -match withinEpsilon

test linmin-1.3 {find minimum of a bell-shaped function} \
    -setup {
	proc f x {
	    set t [expr { $x - 3. }]
	    return [expr { -exp ( -$t * $t / 2 ) }]
	}
    } \
    -body {
	foreach { x y } [min_bound_1d f 0 30.] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 3. \
    -match withinEpsilon

test linmin-1.4 {function where parabolic extrapolation never works} \
    -setup {
	proc f x { expr { -1. / ( 0.01 + abs( $x - 5.) ) } }
    } \
    -body {
	foreach {x y} [min_bound_1d f 0 20.] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 5. \
    -match withinEpsilon

test linmin-2.1 {wrong \# args} \
    -body {
	min_bound_1d f
    } \
    -returnCodes 1 \
    -result [wrongNumArgs min_bound_1d {f x1 x2 args} 1]

test linmin-2.2 {wrong \# args} \
    -body {
	min_bound_1d f 0 1 -bad
    } \
    -returnCodes 1 \
    -result "wrong # args, should be \"min_bound_1d f x1 x2 ?-option value?...\""

test linmin-2.3 {bad arg} \
    -body {
	min_bound_1d f 0 1 -bad option
    } \
    -returnCodes 1 \
    -result "unknown option \"-bad\", should be -abserror,\
             -fguess, -guess, -initial,\
             -maxiter, -relerror, or -trace"

test linmin-2.4 {iteration limit} \
    -setup {
	proc f x { expr { -1. / ( 0.01 + abs( $x - 5.) ) } }
    } \
    -body {
	min_bound_1d f 20. 0 -maxiter 10
    } \
    -cleanup {
	rename f {}
    } \
    -returnCodes 1 \
    -result "min_bound_1d failed to converge after \\d* steps" \
    -match regexp

test linmin-3.1 {minimise cos(x), unbounded} \
    -setup {
	proc f x { expr { cos($x) } }
    } -body {
	foreach { x y } [min_unbound_1d f 3. 3.01] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 3.1415926535897932 \
    -match withinEpsilon

test linmin-3.2 {minimise cos(x), unbounded, too eager} \
    -setup {
	proc f x { expr { cos($x) } }
    } -body {
	foreach { x y } [min_unbound_1d f 0.1 0.15] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result [expr { 3. * 3.1415926535897932 }] \
    -match withinEpsilon

test linmin-3.3 {near underflow in parabolic extrapolation} \
    -setup {
	proc f x {
	    expr { ( 1.12712e-22 * $x * $x * $x - 1e-15 ) * $x + 1e-15 }
	}
    } \
    -body {
	foreach { x y } [min_unbound_1d f 1. 0.] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 130.41372 \
    -match withinEpsilon

test linmin-3.4 {near underflow in parabolic extrapolation} \
    -setup {
	proc f x {
	    expr { ( ( 1e-30 * $x * $x - 1.12712e-22 )
		     * $x * $x * $x - 1e-15 )
		   * $x + 1e-15 }
	}
    } \
    -body {
	foreach { x y } [min_unbound_1d f 1. 0. -relerror 1e-08] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 8668.4248 \
    -match withinEpsilon

test linmin-3.5 {parabolic interpolation finds a minimum - case 1} \
    -setup {
	proc f x {
	    expr { ( ( ( 1e-5 * $x - 2.69672 )
		       * $x + 10.0902 )
		     * $x - 8.39345 )
		   * $x + 1. }
	}
    } \
    -body {
	foreach { x y } [min_unbound_1d f 1. 0. -relerror 1e-08] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 0.527450252 \
    -match withinEpsilon

test linmin-3.6 {parabolic interpolation finds a minimum - case 2} \
    -setup {
	proc f x {
	    expr { ( ( 0.125669 * $x * $x - 0.982687 )
		     * $x - 0.142982 )
		   * $x + 1 }
	}
    } \
    -body {
	foreach { x y } [min_unbound_1d f 1. 0. -relerror 1e-08] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 2.0127451 \
    -match withinEpsilon

test linmin-3.7 {parabolic interpolation is useless} \
    -setup {
	proc f x {
	    expr { ( ( ( 1e-5 * $x - 6.79171 )
		       * $x + 24.8107 )
		     * $x - 19.019 )
		   * $x + 1. }
	}
    } \
    -body {
	foreach { x y } [min_unbound_1d f 1 0 -relerror 1e-8] break
	set x
    } \
    -cleanup {
	rename f {}
    } \
    -result 509375.81 \
    -match withinEpsilon

test linmin-4.1 {wrong \# args} \
    -body {
	min_unbound_1d f
    } \
    -returnCodes 1 \
    -result [wrongNumArgs min_unbound_1d {f x1 x2 args} 1]

test linmin-4.2 {wrong \# args} \
    -body {
	min_unbound_1d f 0 1 -bad
    } \
    -returnCodes 1 \
    -result "wrong # args, should be \"min_unbound_1d f x1 x2 ?-option value?...\""

test linmin-4.3 {bad arg} \
    -body {
	min_unbound_1d f 0 1 -bad option
    } \
    -returnCodes 1 \
    -result "unknown option \"-bad\", should be -trace"

#
# Test the solveLinearProgram procedure
#

set ::symm_constraints {
       { 1.0   2.0  1.0 }
       { 2.0   1.0  1.0 } }

test linprog-1.0 "Symmetric constraints, case 1" \
     -body {
	set result [solveLinearProgram {1.0 1.0} $::symm_constraints]
	set ok 1
	if { ! [within_range [lindex $result 0]  0.333300 0.333360] ||
	     ! [within_range [lindex $result 1]  0.333300 0.333360] } {
	   set ok 0
	}
	set ok
    } \
    -result 1

test linprog-1.1 "Symmetric constraints, case 2" \
     -body {
	set result [solveLinearProgram {1.0 0.0} $::symm_constraints]
	set ok 1
	if { ! [within_range [lindex $result 0]  0.49900 0.50100] ||
	     ! [within_range [lindex $result 1] -0.00100 0.00100] } {
	    set ok 0
	}
	set ok
    } \
    -result 1

test linprog-1.2 "Symmetric constraints, case 3" \
    -body {
	set result [solveLinearProgram {0.0 1.0} $::symm_constraints]
	set ok 1
	if { ! [within_range [lindex $result 1]  0.499900 0.500100] ||
	     ! [within_range [lindex $result 0] -0.000100 0.000100] } {
	      set ok 0
	}
	set ok
    } \
    -result 1

test linprog-1.3 "Symmetric constraints, case 4" \
    -body {
	set result [solveLinearProgram {3.0 4.0} $::symm_constraints]
	set ok 1
	if { ! [within_range [lindex $result 0]  0.333300 0.333360] ||
	     ! [within_range [lindex $result 1]  0.333300 0.333360] } {
	      set ok 0
	}
	set ok
    } \
    -result 1

#
# TODO: Current algorithm makes no difference between infeasible
#       and unbounded
#
test linprog-2.1 "Unbounded program" \
    -body {
	set result [solveLinearProgram {3.0 4.0} {{1.0 -2.0 1.0} {-2.0 1.0 1.0}} ]
    } \
    -result "infeasible"

test linprog-3.1 "Simple 3D program" \
   -body {
	set result [solveLinearProgram \
	   {1.0 1.0 1.0} \
	   {{1.0  1.0  2.0  1.0}
	    {1.0  2.0  1.0  1.0}
	    {2.0  1.0  1.0  1.0}}]
	set ok 1
	if { ! [within_range [lindex $result 0]  0.249900 0.250100] ||
	     ! [within_range [lindex $result 1]  0.249900 0.250100] ||
	     ! [within_range [lindex $result 2]  0.249900 0.250100] } {
	      set ok 0
	}
	set ok
   } \
   -result 1


::tcltest::cleanupTests

# Local Variables:
# mode: tcl
# End:

} ;# End of optimizetest namespace
