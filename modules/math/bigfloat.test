########################################################################
# BigFloat for Tcl
# Copyright (C) 2003-2005  ARNOLD Stephane
#
# BIGFLOAT LICENSE TERMS
#
# This software is copyrighted by Stephane ARNOLD, (stephanearnold <at> yahoo.fr).
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
#
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense, the
# software shall be classified as "Commercial Computer Software" and the
# Government shall have only "Restricted Rights" as defined in Clause
# 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
# authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
#
########################################################################

package forget math::bigfloat
catch { namespace delete ::math::bigfloat }

# Direct loading of provide script -- support testing even
# when not installed.  And be sure we test the local copy
# and not some later version that may be installed.
catch {source [file join [file dirname [info script]] bignum.tcl]}
source [file join [file dirname [info script]] bigfloat.tcl]
namespace import ::math::bigfloat::*


package require tcltest
proc assert {name code result} {
    #puts -nonewline .
    tcltest::test bigfloat-$name-1.0 "eval : '$code'" {uplevel 1 $code} $result
    return
}

interp alias {} zero {} string repeat 0
# S.ARNOLD 08/01/2005
# trying to set the precision of the comparisons to 15 digits
set tcl_precision 15
proc Zero {x} {
    global tcl_precision
    set x [expr {abs($x)}]
    set epsilon 10.0e-$tcl_precision
    return [expr {$x<$epsilon}]
}

proc fassert {name code result} {
    #puts -nonewline .
    set tested [uplevel 1 $code]
    if {[Zero $tested]} {
        tcltest::test bigfloat-$name-1.0 "eval : '$code'" {return [Zero $result]} 1
        return
    }
    set resultat [Zero [expr {($tested-$result)/((abs($tested)>1)?($tested):1.0)}]]
    tcltest::test bigfloat-$name-1.0 "eval : '$code' compare '$tested' and '$result'" {return $resultat} 1
    return
}
# preprocessing is done
#set n


######################################################
# Begin testsuite
######################################################

proc testSuite {} {
    
    
    # adds 999..9 and 1 -> 1000..0
    for {set i 1} {$i<15} {incr i} {
        assert add {tostr [add \
                    [fromstr [string repeat 999 $i]] [fromstr 1]]
        } 1[string repeat 000 $i]
    }
    # sub 1000..0 1 -> 999..9
    for {set i 1} {$i<15} {incr i} {
        assert sub {tostr [sub [fromstr 1[string repeat 000 $i]] [fromstr 1]]} \
                [string repeat 999 $i]
    }
    # mul 10001000..1000 with 1..9
    for {set i 1} {$i<15} {incr i} {
        foreach j {1 2 3 4 5 6 7 8 9} {
            assert mul {tostr [mul [fromstr [string repeat 1000 $i]] [fromstr $j]]} \
                    [string repeat ${j}000 $i]
        }
    }
    # div 10^8 by 1 .. 9
    for {set i 1} {$i<=9} {incr i} {
        assert div {tostr [div [fromstr 100000000] [fromstr $i]]} [expr {wide(100000000)/$i}]
    }
    
    
    # 10^8 modulo 1 .. 9
    for {set i 1} {$i<=9} {incr i} {
        assert mod {tostr [mod [fromstr 100000000] [fromstr $i]]} [expr {wide(100000000)%$i}]
    }
    
    ################################################################################
    # fromstr problem with octal exponents
    ################################################################################
    fassert fromstr {todouble [fromstr 1.0e+099]} 1.0e+099
    fassert fromstr {todouble [fromstr 1.0e99]} 1.0e99 
    fassert fromstr {todouble [fromstr 1.0e-99]} 1.0e-99
    fassert fromstr {todouble [fromstr 1.0e-099]} 1.0e-99
    
    
    ################################################################################
    # fromdouble with precision
    ################################################################################
    assert fromdouble {tostr [ceil [fromdouble 1.0e99 100]]} 1[zero 99]
    assert fromdouble {tostr [fromdouble 1.11 3]} 1.11
    assert fromdouble {tostr [fromdouble +1.11 3]} 1.11
    assert fromdouble {tostr [fromdouble -1.11 3]} -1.11
    assert fromdouble {tostr [fromdouble +01.11 3]} 1.11
    assert fromdouble {tostr [fromdouble -01.11 3]} -1.11
    # more to come...
    fassert fromdouble {compare [fromdouble [expr {atan(1.0)*4}]] [pi $::tcl_precision]} 0
    
    ################################################################################
    # abs()
    ################################################################################
    proc absTest {x {int 0}} {
        if {!$int} {
            fassert abs {
                tostr [abs [fromstr $x]]
            } [expr {abs($x)}]
        } else {
            assert abs {
                tostr [abs [fromstr $x]]
            } [expr {($x<0)?(-$x):$x}]
        }
        
    }
    absTest 1.000
    absTest -1.000
    absTest -0.10
    absTest 0 1
    absTest 1 1
    absTest 10000 1
    absTest -1 1
    absTest -10000 1
    rename absTest ""
    
    ################################################################################
    # opposite
    ################################################################################
    proc oppTest {x {int 0}} {
        if {$int} {
            assert opp {tostr [opp [fromstr $x]]} [expr {-$x}]
        } else {
            fassert opp {tostr [opp [fromstr $x]]} [expr {-$x}]
        }
        
    }
    oppTest 1.00
    oppTest -1.00
    oppTest 0.10
    oppTest -0.10
    oppTest 0.00
    oppTest 1 1
    oppTest -1 1
    oppTest 0 1
    oppTest 100000000 1
    oppTest -100000000 1
    rename oppTest ""
    
    ################################################################################
    # equal
    ################################################################################
    proc equalTest {x y} {
        equal [fromstr $x] [fromstr $y]
    }
    assert equal {equalTest 0.0 0.1} 1
    assert equal {equalTest 0.00 0.10} 0
    assert equal {equalTest 0.0 -0.1} 1
    assert equal {equalTest 0.00 -0.10} 0
    
    rename equalTest ""
    ################################################################################
    # compare
    ################################################################################
    proc compareTest {x y} {
        compare [fromstr $x] [fromstr $y]
    }
    assert cmp {compareTest 0.00 0.10} -1
    assert cmp {compareTest 0.1 0.4} -1
    assert cmp {compareTest 0.0 -1.0} 1
    assert cmp {compareTest -1.0 0.0} -1
    assert cmp {compareTest 0.00 0.10} -1
    
    # cleanup
    rename compareTest ""
    
    ################################################################################
    # round
    ################################################################################
    proc roundTest {x} {
        assert round {tostr [round [fromstr $x]]} [expr {round($x)}]
    }
    roundTest 0.10
    roundTest 0.0
    roundTest 0.50
    roundTest 0.40
    roundTest 1.0
    roundTest -0.40
    roundTest -0.50
    roundTest -1.0
    
    # cleanup
    rename roundTest ""
    
    ################################################################################
    # floor
    ################################################################################
    proc floorTest {x} {
        assert floor {tostr [floor [fromstr $x]]} [expr {int(floor($x))}]
    }
    floorTest 0.10
    floorTest 0.90
    floorTest 1.0
    floorTest -0.10
    floorTest -1.0
    
    # cleanup
    rename floorTest ""
    
    ################################################################################
    # ceil
    ################################################################################
    proc ceilTest {x} {
        assert ceil {tostr [ceil [fromstr $x]]} [expr {int(ceil($x))}]
    }
    ceilTest 0.10
    ceilTest 0.90
    ceilTest 1.0
    ceilTest -0.10
    ceilTest -1.0
    ceilTest 0.0
    
    # cleanup
    rename ceilTest ""
    
    ################################################################################
    # BigInt to BigFloat conversion
    ################################################################################
    proc convTest {x {decimals 1}} {
        assert int2float {tostr [int2float [fromstr $x] $decimals]} \
                $x.[string repeat 0 [expr {$decimals-1}]]
    }
    foreach decimals {1 2 5 10 100} {
        assert int2float {tostr [int2float [fromstr 0] $decimals]} 0
        convTest 1 $decimals
        convTest 5 $decimals
        convTest 5000000000 $decimals
    }
    #cleanup
    rename convTest ""
    
    ################################################################################
    # addition
    ################################################################################
    proc addTest {x y} {
        fassert add {todouble [add [fromstr $x] [fromstr $y]]} [expr {$x+$y}]
    }
    addTest 1.00 2.00
    addTest -1.00 2.00
    addTest 1.00 -2.00
    addTest -1.00 -2.00
    addTest 0.00 1.00
    addTest 0.00 -1.00
    addTest 1 2.00
    addTest 1 -2.00
    addTest 0 1.00
    addTest 0 -1.00
    addTest 2.00 1
    addTest -2.00 1
    addTest 1.00 0
    addTest -1.00 0
    #cleanup
    rename addTest ""
    
    ################################################################################
    # substraction
    ################################################################################
    proc subTest {x y} {
        fassert sub {todouble [sub [fromstr $x] [fromstr $y]]} [expr {$x-$y}]
    }
    subTest 1.00 2.00
    subTest -1.00 2.00
    subTest 1.00 -2.00
    subTest -1.00 -2.00
    subTest 0.00 1.00
    subTest 0.00 -1.00
    subTest 1 2.00
    subTest 1 -2.00
    subTest 0 2.00
    subTest 0 -2.00
    subTest 2 0.00
    subTest 2.00 1
    subTest 1.00 2
    subTest -1.00 1
    subTest 0.00 2
    subTest 2.00 0
    # cleanup
    rename subTest ""
    
    ################################################################################
    # multiplication
    ################################################################################
    proc mulTest {x y} {
        fassert mul {todouble [mul [fromstr $x] [fromstr $y]]} [expr {$x*$y}]
    }
    proc mulInt {x y} {
        mulTest $x $y
        mulTest $y $x
    }
    mulTest 1.00 2.00
    mulTest -1.00 2.00
    mulTest 1.00 -2.00
    mulTest -1.00 -2.00
    mulTest 0.00 1.00
    mulTest 0.00 -1.00
    mulTest 1.00 10.0
    mulInt 1 2.00
    mulInt 1 -2.00
    mulInt 0 2.00
    mulInt 0 -2.00
    mulInt 10 2.00
    mulInt 10 -2.00
    mulInt 1 0.00
    
    
    # cleanup
    rename mulTest ""
    rename mulInt ""
    
    ################################################################################
    # division
    ################################################################################
    proc divTest {x y} {
        fassert div {
            string trimright [todouble [div [fromstr $x] [fromstr $y]]] 0
        } [string trimright [expr {$x/$y}] 0]
    }
    
    
    divTest 1.00 2.00
    divTest 2.00 1.00
    divTest -1.00 2.00
    divTest 1.00 -2.00
    divTest 2.00 -1.00
    divTest -2.00 1.00
    divTest -1.00 -2.00
    divTest -2.00 -1.00
    divTest 0.0 1.0
    divTest 0.0 -1.0
    
    # cleanup
    rename divTest ""
    
    ################################################################################
    # rest of the division
    ################################################################################
    proc modTest {x y} {
        fassert mod {
            todouble [mod [fromstr $x] [fromstr $y]]
        } [expr {fmod($x,$y)}]
    }
    
    modTest 1.00 2.00
    modTest 2.00 1.00
    modTest -1.00 2.00
    modTest 1.00 -2.00
    modTest 2.00 -1.00
    modTest -2.00 1.00
    modTest -1.00 -2.00
    modTest -2.00 -1.00
    modTest 0.0 1.0
    modTest 0.0 -1.0
    
    modTest 1.00 2
    modTest 2.00 1
    modTest -1.00 2
    modTest -2.00 1
    modTest 0.0 1
    modTest 1.50 1
    
    # cleanup
    rename modTest ""
    
    ################################################################################
    # divide a BigFloat by an integer
    ################################################################################
    proc divTest {x y} {
        fassert div {todouble [div [fromstr $x] [fromstr $y]]} \
            [expr {double(round(1000*$x/$y))/1000.0}]
    }
    
    foreach a {1.0000 -1.0000} {
        foreach b {2 3} {
            divTest $a $b
        }
    }
    
    # cleanup
    rename divTest ""
    
    ################################################################################
    # pow : takes a float to an integer power (>0)
    ################################################################################
    proc powTest {x y {int 0}} {
        if {!$int} {
            fassert pow {todouble [pow [fromstr $x 14] [fromstr $y]]}\
                    [expr [join [string repeat "[string trimright $x 0] " $y] *]]
        } else  {
            assert pow {tostr [pow [fromstr $x] [fromstr $y]]}\
                    [expr [join [string repeat "$x " $y] *]]
        }
    }
    
    foreach a {1 -1 2 -2 5 -5} {
        foreach b {2 3 7 16} {
            powTest $a. $b
        }
    }
    
    foreach a {1 2 3} {
        foreach b {2 3 5 8} {
            powTest $a $b 1
        }
    }
    
    # cleanup
    rename powTest ""
    
    
    ################################################################################
    # pi constant and angles conversion
    ################################################################################
    fassert pi {todouble [pi 16]} [expr {atan(1)*4}]
    # converts Pi -> 180°
    fassert rad2deg {todouble [rad2deg [pi 20]]} 180.0
    # converts 180° -> Pi
    fassert deg2rad {todouble [deg2rad [fromstr 180.0 20]]} [expr {atan(1.0)*4}]
    
    
    ################################################################################
    # iszero : the precision is too small to determinate the number
    ################################################################################
    
    assert iszero {iszero [fromstr 0]} 1
    assert iszero {iszero [fromstr 0.0]} 1
    assert iszero {iszero [fromstr 1]} 0
    assert iszero {iszero [fromstr 1.0]} 0
    assert iszero {iszero [fromstr -1]} 0
    assert iszero {iszero [fromstr -1.0]} 0
    
    ################################################################################
    # sqrt : square root
    ################################################################################
    proc sqrtTest {x} {
        fassert sqrt {todouble [sqrt [fromstr $x 18]]} [expr {sqrt($x)}]
    }
    sqrtTest 1.
    sqrtTest 0.001
    sqrtTest 0.004
    sqrtTest 4.
    
    # cleanup
    rename sqrtTest ""
    
    
    ################################################################################
    # expTest : exponential function
    ################################################################################
    proc expTest {x} {
        fassert exp {todouble [exp [fromstr $x 17]]} [expr {exp($x)}]
    }
    
    expTest 1.
    expTest 0.001
    expTest 0.004
    expTest 40.
    expTest -0.001
    
    # cleanup
    rename expTest ""
    
    ################################################################################
    # logTest : logarithm
    ################################################################################
    proc logTest {x} {
        fassert log {todouble [log [fromstr $x 17]]} [expr {log($x)}]
    }
    
    logTest  1.0
    logTest 0.001
    logTest 0.004
    logTest 40.
    logTest 1[zero 10].0
    
    # cleanup
    rename logTest ""
    
    ################################################################################
    # cos & sin : trigonometry
    ################################################################################
    proc cosEtSin {quartersOfPi} {
        set x [div [mul [pi 18] [fromstr $quartersOfPi]] [fromstr 4]]
        #fassert cos {todouble [cos $x]} [expr {cos(atan(1)*$quartersOfPi)}]
        #fassert sin {todouble [sin $x]} [expr {sin(atan(1)*$quartersOfPi)}]
        fassert cos {todouble [cos $x]} [expr {cos([todouble $x])}]
        fassert sin {todouble [sin $x]} [expr {sin([todouble $x])}]
    }
    
    fassert cos {todouble [cos [fromstr 0. 17]]} [expr {cos(0)}]
    fassert sin {todouble [sin [fromstr 0. 17]]} [expr {sin(0)}]
    foreach i {1 2 3 4 5 6 7 8} {
        cosEtSin $i
    }
    
    
    # cleanup
    rename cosEtSin ""
    
    ################################################################################
    # tan & cotan : trigonometry
    ################################################################################
    proc tanCotan {i} {
        upvar pi pi
        set x [div [mul $pi [fromstr $i]] [fromstr 10]]
        set double [expr {atan(1)*(double($i)*0.4)}]
        fassert cos {todouble [cos $x]} [expr {cos($double)}]
        fassert sin {todouble [sin $x]} [expr {sin($double)}]
        fassert tan {todouble [tan $x]} [expr {tan($double)}]
        fassert cotan {todouble [cotan $x]} [expr {double(1.0)/tan($double)}]
    }
    
    set pi [pi 20]
    foreach i {1 2 3 6 7 8 9} {
        tanCotan $i
    }
    
    
    # cleanup
    rename tanCotan ""
    
    
    ################################################################################
    # atan , asin & acos : trigonometry (inverse functions)
    ################################################################################
    proc atanTest {x} {
        set f [fromstr $x 20]
        if {abs($x)<=1.0} {
            fassert acos {todouble [acos $f]} [expr {acos($x)}]
            fassert asin {todouble [asin $f]} [expr {asin($x)}]
        }
        fassert atan {todouble [atan $f]} [expr {atan($x)}]
    }
    
    atanTest 0.0
    foreach i {1 2 3 4 5 6 7 8 9} {
        atanTest 0.$i
        atanTest $i.0
        atanTest -0.$i
        atanTest -$i.0
    }
    
    # cleanup
    rename atanTest ""
    
    ################################################################################
    # cosh , sinh & tanh : hyperbolic functions
    ################################################################################
    proc hyper {x} {
        set f [fromstr $x 18]
        fassert cosh {todouble [cosh $f]} [expr {cosh($x)}]
        fassert sinh {todouble [sinh $f]} [expr {sinh($x)}]
        fassert tanh {todouble [tanh $f]} [expr {tanh($x)}]
    }
    
    hyper 0.0
    foreach i {1 2 3 4 5 6 7 8 9} {
        hyper 0.$i
        hyper $i.0
        hyper -0.$i
        hyper -$i.0
    }
    
    # cleanup
    rename hyper ""
    
}

testSuite
################################################################################
# end of testsuite for bigfloat 1.0
################################################################################
# cleanup global procs
rename assert ""
rename fassert ""
rename Zero ""

tcltest::cleanupTests
