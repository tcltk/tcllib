[comment {-*- tcl -*- doctools manpage}]
[vset VERSION 0.3]
[manpage_begin bee n [vset VERSION]]
[keywords bee]
[keywords BitTorrent]
[keywords bittorrent]
[keywords serialization]
[keywords torrent]
[copyright {2004 Andreas Kupries <andreas_kupries@users.sourceforge.net>}]
[moddesc   {BitTorrent}]
[titledesc {BitTorrent Serialization Format Encoder/Decoder}]
[category  Networking]
[require Tcl "8.5 9"]
[require bee [opt [vset VERSION]]]
[description]
[para]

This package provides encoding and decoding commands for data in Bencode
(spoken as “bee-encode”), the BitTorrent protocol’s serialization format
used for data and messages.

[para]

[section API]

[subsection Encoder]

This package provides an encoder command for each value type (string and
integer), and two commands per collection type (list and dict), one
taking a complete Tcl collection to encode, the other taking the same
data given as arguments.

[para]
[list_begin definitions]

[call [cmd ::bee::encodeString] [arg string]]

Returns the bee-encoding of the [arg string].

[call [cmd ::bee::encodeNumber] [arg integer]]

Returns the bee-encoding of the [arg integer] number.

[para]
This command will throw an error if [arg integer] is not an integer.

[call [cmd ::bee::encodeListArgs] [opt [arg {beevalue ...}]]]

Returns a bee-encoded list of the given zero or more bee-encoded
[arg beevalue]s.

[call [cmd ::bee::encodeList] [arg listofbees]]

Returns a bee-encoded list of the given Tcl list, [arg listofbees], of
bee-encoded values.

[call [cmd ::bee::encodeDictArgs] [opt [arg {key beevalue ...}]]]

Returns a bee-encoded dict of the given zero or more pairs of Tcl string
keys and bee-encoded [arg beevalue]s.

[para]
This command will bee-encode each string key itself.

[call [cmd ::bee::encodeDict] [arg dictofbees]]

Returns a bee-encoded dict of the given Tcl dict, [arg dictofbees],
whose keys must be Tcl strings and whose values must be bee-encoded
values.

[para]
This command will bee-encode each string key itself.

[list_end]
[para]

[subsection Decoder]

This package provides decoding commands for bee-encoded strings and for
bee-encoded data received over a channel.

[para]
The commands for decoding a bee-encoded string expect the string to
contain one or more complete bee-encoded values (which may themselves
contain nested bee-encoded lists and dicts).

[para]
The command for the incremental decoding of bee-values arriving on a
channel is asynchronous and provides the completed decoded values via a
callback.

[para]
[list_begin definitions]

[call [cmd ::bee::decode] [arg beestring] [opt [arg endVar]] \
[opt [arg start]]]

Returns a bee-decoded value from the [arg beestring], starting from
index position [arg start] if given—or from its default of [const 0],
and sets [arg endVar] if given.

[para]
If the bee-encoded value is a string or integer, the equivalent Tcl
string or integer is returned.

[para]
If the bee-encoded value is a collection (a bee-list or a bee-dict),
then a corresponding Tcl list or Tcl dict is returned. And in either of
these cases, all contained values (including nested bee-lists and
bee-dicts) are all bee-decoded, so that the result is a Tcl list or dict
with all the nested values fully bee-decoded into Tcl lists, dicts,
strings, or integers, as appropriate.

[para]
If the option [arg endVar] is given, it is the name of a variable used
to store the index position of the first character in the [arg beestring]
that [emph follows] the value that’s just been decoded, i.e., the start
position of the next value to decode. This is useful if the
[arg beestring] contains two or more bee-encoded values concatenated
together (as opposed to a single bee-encoded list of bee-encoded
values). See the last example in the [sectref Examples].

[para]
The optional [arg start] is the index position from which the next
bee-encoded value will be read and decoded.

[call [cmd ::bee::decodeIndices] [arg beestring] [opt [arg endVar]] \
[opt [arg start]]]

Returns a list based on the bee-decoded value from the [arg beestring],
starting from index position [arg start] if given—or from its default of
[const 0], and sets [arg endVar] if given. The meaning and use of
[arg endVar] and [arg start] are exactly the same as for
[cmd ::bee::decode].

[para]
The returned list’s elements depend on the type of the bee-decoded
value. In all cases though, the first element is a type name (one of 
[const string] [const integer] [const list] [const dict]), and the
second and third elements are the start and end index positions in the
[arg beestring] for the bee-encoded value. For bee-lists and bee-dicts
there is a fourth element which provides details of their contained
bee-values.

[para]

Formally the result lists for the various types of bee-values are:

[list_begin definitions]
[def string]

A list containing three elements:

[list_begin itemized]
[item]
A constant string indicating the value’s type, for strings it is
[const string].

[item]
The index position ([emph {>= 0}]) of the first character of the bee-value
in the given [arg beestring].

[item]
The index position ([emph {>= 0}]) of the last character of the bee-value
in the given [arg beestring].

[list_end]
[para]

[emph {Every result list, for every bee-value, begins with these three
elements.}]

[def integer]

A list containing the constant string [const integer] and—just the same
as for strings—the start and end index positions of the bee-value in the
[arg beestring].

[def list]

A list containing the constant string [const list] and—just the same
as for strings—the start and end index positions of the bee-value in the
[arg beestring].

[para]
In addition the list has a fourth element, which itself contains
the index data as described here for all the elements of the bee-list.

[def dictionary]

A list containing the constant string [const dict] and—just the same
as for strings—the start and end index positions of the bee-value in the
[arg beestring].

[para]
In addition the dict has a fourth element. This element is a dictionary
mapping from each of the bee-dict’s string keys to a 2-element list of
2-element lists. The list’s first element’s list contains the index
positions for the key, and the second element’s list contains the index
positions for the value the key maps to. This structure is the only one
which contains not only index positions, but actual values from the
[arg beestring]. While each key’s index positions are unique,
i.e., usable as a key, they are not easy to navigate when trying to find
a particular element. Using actual keys makes navigation much easier, which
is why they’re provided.

[list_end]
[para]

[call [cmd ::bee::decodeChannel] [arg chan] \
	[option -command] [arg cmdprefix] \
	[opt [option -exact]] \
	[opt "[option -prefix] [arg data]"] \
]

The command creates a decoder for a series of bee-values arriving on
the channel [arg chan] and returns its handle. This handle can be used
to remove the decoder again.

Setting up another bee decoder on [arg chan] while a bee decoder is
still active will fail with an error message.

[para]
[list_begin definitions]
[def [option -command]]

The command prefix [arg cmdprefix] specified by the [emph required]
option [option -command] is used to report extracted values and
exceptional situations (error, and EOF on the channel).

The callback will be executed at the global level of the interpreter,
with two or three arguments. The exact call signatures are

[para]
[list_begin definitions]
[call [cmd cmdprefix] [method eof] [arg token]]

The decoder has reached eof on the channel [arg chan]. No further
invocations of the callback will be made after this. The channel has
already been closed at the time of the call, and the [arg token] is
not valid anymore as well.

[call [cmd cmdprefix] [method error] [arg token] [arg message]]

The decoder encountered an error, which is not eof. For example a
malformed bee-value. The [arg message] provides details about the
error. The decoder token is in the same state as for eof,
i.e. invalid. The channel however is kept open.

[call [cmd cmdprefix] [method value] [arg token] [arg value]]

The decoder received and successfully decoded a bee-value.

The format of the equivalent tcl [arg value] is the same as returned
by [cmd ::bee::decode]. The channel is still open and the decoder
token is valid. This means that the callback is able to remove the
decoder.

[list_end]
[para]

[def [option -exact]]

By default the decoder assumes that the remainder of the data in the
channel consists only of bee-values, and reads as much as possible per
event, without regard for boundaries between bee-values. This means
that if the the input contains non-bee data after a series of
bee-value the beginning of that data may be lost because it was
already read by the decoder, but not processed.

[para]

The [option -exact] was made for this situation. When specified the
decoder will take care to not read any characters behind the currently
processed bee-value, so that any non-bee data is kept in the channel
for further processing after removal of the decoder.

[para]

[def [option -prefix]]

If this option is specified its value is assumed to be the beginning
of the bee-value and used to initialize the internal decoder
buffer. This feature is required if the creator of the decoder used
data from the channel to determine if it should create the decoder or
not. Without the option this data would be lost to the decoding.

[list_end]
[para]

[call [cmd ::bee::decodeCancel] [arg token]]

This command cancels the decoder set up by [cmd ::bee::decodeChannel]
and represented by the handle [arg token].

[call [cmd ::bee::decodePush] [arg token] [arg string]]

This command appends the [arg string] to the internal decoder
buffer. It is the runtime equivalent of the option [option -prefix] of
[cmd ::bee::decodeChannel]. Use it to push data back into the decoder
when the [method value] callback used data from the channel to
determine if it should decode another bee-value or not.

[list_end]
[para]

[section {Format Definition}]

Data in the bee serialization format is constructed from two basic
forms, and two container forms. The basic forms are strings and
integer numbers, and the containers are lists and dictionaries.

[para]
[list_begin definitions]
[def "String [arg S]"]

A string [arg S] of length [arg L] is encoded by the string

"[arg L][const :][arg S]", where the length is written out in textual
form.

[def "Integer [arg N]"]

An integer number [arg N] is encoded by the string

"[const i][arg N][const e]".

[def "List [arg v1] ... [arg vn]"]

A list of the values [arg v1] to [arg vn] is encoded by the string

"[const l][arg BV1]...[arg BVn][const e]"

where "BV[var i]" is the bee-encoding of the value "v[var i]".

[def "Dict [arg k1] -> [arg v1] ..."]

A dictionary mapping the string key [arg k][var i] to the value

[arg v][var i], for [var i] in [const 1] ... [var n]
is encoded by the string

"[const d][arg BK][var i][arg BV][ var i]...[const e]"

for i in [const 1] ... [var n], where "BK[var i]" is the bee-encoding
of the key string "k[var i]".  and "BV[var i]" is the bee-encoding of
the value "v[var i]".

[para]

[emph Note]: The bee-encoding does not retain the order of the keys in
the input, but stores in a sorted order. The sorting is done for the
"raw strings".

[list_end]
[para]

Note that the type of each encoded item can be determined immediately
from the first character of its representation:

[para]
[list_begin definitions]
[def i]
Integer.
[def l]
List.
[def d]
Dictionary.
[def "[lb]0-9[rb]"]
String.
[list_end]
[para]

By wrapping an integer number into [const i]...[const e] the format
makes sure that they are different from strings, which all begin with
a digit.

[section Examples]

This example shows how to bee-encode and bee-decode individual strings
and integers.

[para]
[example {
const LABEL "Δ÷ “Utf-8” ♞ℤ"
set labelbeeEnc [::bee::encodeString $LABEL]
set labelbeeDec [::bee::decode $labelbeeEnc]
puts "labelbeeEnc='$labelbeeEnc' eq LABEL → [expr {$labelbeeDec eq $LABEL}]"
set xbeeEnc [::bee::encodeNumber 834]
set ybeeEnc [::bee::encodeNumber -172]
set ybeeDec [::bee::decode $ybeeEnc]
puts "ybeeEnc='$ybeeEnc' == -172 → [expr {$ybeeDec == -172}]"
=>
labelbeeEnc='13:Δ÷ “Utf-8” ♞ℤ' eq LABEL → 1
ybeeEnc='i-172e' == -172 → 1
}]

This example shows how to bee-encode collections of bee-encoded values.

[para]
[example {
set pointbeeEnc [::bee::encodeList [list $xbeeEnc $ybeeEnc]]
set placebeeEnc [::bee::encodeDictArgs label $labelbeeEnc point $pointbeeEnc]
puts "pointbeeEnc='$pointbeeEnc'"
puts "placebeeEnc='$placebeeEnc'"
=>
pointbeeEnc='li834ei-172ee'
placebeeEnc='d5:label13:Δ÷ “Utf-8” ♞ℤ5:pointli834ei-172eee'
}]

This example shows how to bee-decode collections of bee-encoded values.

[para]
[example {
set placebeeDec [::bee::decode $placebeeEnc]
set label [dict get $placebeeDec label]
puts "label='$label' eq LABEL → [expr {$label eq $LABEL}]"
lassign [dict get $placebeeDec point] x y
puts "x=$x == 834 → [expr {$x == 834}] • y=$y == -172 → [expr {$y == -172}]"
=>
label='Δ÷ “Utf-8” ♞ℤ' eq LABEL → 1
x=834 == 834 → 1 • y=-172 == -172 → 1
}]

This example shows how to bee-decode using the
[cmd ::bee::decodeIndices] command.

[para]
[example {
set labelbeeDecInd [::bee::decodeIndices $labelbeeEnc]
lassign $labelbeeDecInd type i j
set label [::bee::decode [string range $labelbeeEnc $i $j]]
puts "labelbeeDecInd type=$type i=$i j=$j label='$label'"
=>
labelbeeDecInd type=string i=0 j=15 label='Δ÷ “Utf-8” ♞ℤ'
}]

This example shows how to bee-encode and then bee-decode a sequence of
[emph separate] bee-encoded values.

[para]
[example {
set stream [::bee::encodeString "€⅔•"][::bee::encodeNumber -91][::bee::encodeString "α-ω"][::bee::encodeNumber 68]
for {set i 0} {$i < [string length $stream]} {} {
    lappend items [::bee::decode $stream i $i]
}
puts "stream='$stream' items={$items} size=[llength $items]"
=>
stream='3:€⅔•i-91e3:α-ωi68e' items={€⅔• -91 α-ω 68} size=4
}]

[vset CATEGORY bee]
[include ../common-text/feedback.inc]
[manpage_end]
