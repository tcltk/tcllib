[vset VERSION 1.3]
[manpage_begin string::token::shell n [vset VERSION]]
[keywords bash]
[keywords lexing]
[keywords parsing]
[keywords shell]
[keywords string]
[keywords tokenization]
[moddesc   {Text and string utilities}]
[titledesc {Parsing of shell command line}]
[category  {Text processing}]
[require Tcl "8.5 9"]
[require string::token::shell [opt [vset VERSION]]]
[require string::token [opt 1]]
[require fileutil]
[description]

This package provides a command which parses a line of text using
basic [syscmd sh]-syntax into a list of words.

[para]

The complete set of procedures is described below.

[list_begin definitions]

[call [cmd {::string token shell}] [opt [option -indices]] [opt [option -partial]] [opt --] [arg string]]

By default, returns a list of words from the input [arg string]. The
words are split from [arg string] in accordance with basic
[uri https://man7.org/linux/man-pages/man1/sh.1p.html sh(1p)]-syntax.

[para]
An error is thrown if the input does not follow the expected syntax.

[para]
The command’s behaviour can be modified by specifying any of the two options
[option -indices] and [option -partial].

[list_begin options]
[opt_def --]

When specified option parsing stops at this point. This option is
needed if the input [arg string] may start with dash. In other words,
this is pretty much required if [arg string] is user input.

[opt_def -indices]

When specified the command returns a list of 4-element lists. Each
4-element list contains the type of the word, its start and end indexes
in the [arg string], and the word itself (copied from the [arg string]).

[para]
For any given 4-element list, the length of the word as calculated by
the difference between the indices may not match the length of the word
in the last element. This is because the indices include delimeters,
intra-word quoting, etc., whereas the word in the last element has all
these stripped away.

[para] The possible token types are
[list_begin definitions]
[def [const PLAIN]]
Plain word, not quoted.

[def [const D:QUOTED]]
Word was delimited by double-quotes.

[def [const S:QUOTED]]
Word was delimited by single-quotes.

[def [const D:QUOTED:PART]]
[def [const S:QUOTED:PART]]

Like the previous types, but the word has no closing quote, i.e., is
incomplete. These token types can only occur if the [option -partial]
option was specified, and then only for the last word of the result. If
the option [option -partial] is [emph not] specified, an incomplete last
word will cause the command to throw an error instead.

[list_end]

[opt_def -partial]

When specified, the parser will accept an incomplete quoted word (i.e.,
with an opening quote but no matching closing quote), at the end of the
[arg string], without throwing an error.

[list_end]

[para] The basic shell syntax accepted by this command are unquoted,
single- and double-quoted words, separated by whitespace. Leading and
trailing whitespace are permitted too, and if present are stripped.

[para]
Shell variables in their various forms are [emph not] recognized, nor
are sub-shells.

[para]
Here are the recognized forms of words:

[list_begin definitions]

[def [const {single-quoted word}]]

A single-quoted word begins with a single-quote character, i.e.
[const '] (ASCII 39; U+0027) followed by zero or more unicode characters
excluding single-quote, and ending with a single-quote.

[para]
The word must be followed by either the end of the [arg string], or by
whitespace. A word cannot directly follow another word with nothing
inbetween.

[def [const {double-quoted word}]]

A double-quoted word begins with a double-quote character, i.e.
[const {"}] (ASCII 34; U+0022) followed by zero or more unicode
characters excluding double-quote, and ending with a double-quote.

[para]
Unlike for single-quoted words, double-quotes can be embedded in
double-quoted words by escaping them using a backslash character
[const \\] (ASCII 92; U+005C), e.g., [const {"…\"…"}]. Similarly, any
literal backslash can be embedded by being backslash-escaped, e.g.,
[const {"…\\…"}].

[def [const {unquoted word}]]

Unquoted words are not delimited by quotes and thus cannot contain
whitespace or single-quote characters. However, double-quote and
backslash characters can be put into unquoted words by escaping them as
for double-quoted words.

[def [const whitespace]]

Whitespace is any unicode whiespace character, i.e., any character for
which
[uri https://www.tcl-lang.org/man/tcl/TclCmd/string.html {string is space}]
returns [const 1] (true), or which matches
the regular expression [const {\\s}].

[para]
Whitespace [emph may] occur before the first word, and after the last
word. Whitespace [emph must] occur between adjacent words.

[list_end]
[list_end]

[section Examples]
[para]

An example of a command line parsed into its constituent words.

[example {
const CMDLINE "grep --include=*.{tcl,tm,tk} -rl * | grep -v \"The Cloud\""
puts "CMDLINE=«$CMDLINE»"
foreach word [string token shell $CMDLINE] {
    puts "word=«$word»"
}
=>
CMDLINE=«grep --include=*.{tcl,tm,tk} -rl * | grep -v "The Cloud"»
word=«grep»
word=«--include=*.{tcl,tm,tk}»
word=«-rl»
word=«*»
word=«|»
word=«grep»
word=«-v»
word=«The Cloud»
}]
[para]

An example of the same command line used above, parsed into its
constituent words, with tokens and string indices.

[example {
foreach element [string token shell -indices $CMDLINE] {
    lassign $element token i j word
    puts "token=$token i=$i j=$j word=«$word»"
}
=>
token=PLAIN i=0 j=3 word=«grep»
token=PLAIN i=5 j=27 word=«--include=*.{tcl,tm,tk}»
token=PLAIN i=29 j=31 word=«-rl»
token=PLAIN i=33 j=33 word=«*»
token=PLAIN i=35 j=35 word=«|»
token=PLAIN i=37 j=40 word=«grep»
token=PLAIN i=42 j=43 word=«-v»
token=D:QUOTED i=45 j=55 word=«The Cloud»
}]

[vset CATEGORY textutil]
[include ../common-text/feedback.inc]
[manpage_end]
