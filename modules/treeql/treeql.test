# -*- tcl -*-
# treeql.test:  tests for the tree query language
#
# Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.

if {![package vsatisfies [package provide Tcl] 8.4]} {
    puts "Aborting tests for treeql."
    puts "Requiring Tcl 8.4, have [package present Tcl]"
    return
}

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import ::tcltest::*
}

# -------------------------------------------------------------------------
# Ensure we test _this_ local copy and one installed somewhere else.
#
package forget treeql 1.0
package forget struct::tree
package forget struct::list
package forget struct::set
package forget snit

catch {namespace delete ::treeql}
## catch {namespace delete ::struct::tree} ##
catch {namespace delete ::struct::list}
catch {namespace delete ::struct::set}
catch {namespace delete ::snit}

set moddir  [file dirname [file dirname [file join [pwd] [info script]]]]
set tcllibc [file join $moddir tcllibc pkgIndex.tcl]

if {[file exists $tcllibc]} {
    # Fake load of specific package index, so that the following
    # require will not search through the package paths.
    set dir [file dirname $tcllibc]
    source $tcllibc
    unset dir
    package require tcllibc
}

set moddir [file dirname [file dirname [file normalize [info script]]]]
if {[catch {source [file join $moddir treeql treeql.tcl]} msg]} {
    puts "skipped [file tail [info script]] (treeql.tcl): $msg"
    return
}
if {[catch {source [file join $moddir struct tree.tcl]} msg]} {
    puts "skipped [file tail [info script]] (struct/tree.tcl): $msg"
    return
}
if {[catch {source [file join $moddir struct list.tcl]} msg]} {
    puts "skipped [file tail [info script]] (struct/list.tcl): $msg"
    return
}
if {[catch {source [file join $moddir struct sets.tcl]} msg]} {
    puts "skipped [file tail [info script]] (struct/set.tcl): $msg"
    return
}
if {[catch {source [file join $moddir snit snit.tcl]} msg]} {
    puts "skipped [file tail [info script]] (snit.tcl): $msg"
    return
}

package require treeql
package require struct::tree
package require struct::list
package require struct::set
package require snit

package require struct::tree
puts "- treeql [package present treeql]"
puts "  - snit         [package present snit]"
puts "  - struct::list [package present struct::list]"
puts "  - struct::set  [package present struct::set]"

struct::tree::SwitchTo {}
foreach e [struct::tree::KnownImpl] {
    if {[::struct::tree::LoadAccel $e]} {
	puts "  - struct::tree [package provide struct::tree] (using $e)"
	switch -exact -- $e {
	    critcl {
		puts "  - tcllibc      [package present tcllibc]"
	    }
	    tcl {}
	}
    }
}

# -------------------------------------------------------------------------
# We now run the tests. As they depend on a struct::tree, we have to
# test all the available implementations.

set tests [file join [file dirname [info script]] treeql.testsuite]

puts ""
catch {memory validate on}

foreach impl [struct::tree::Implementations] {
    struct::tree::SwitchTo $impl

    # The global variable 'impl' is part of the public API the
    # testsuit (in htmlparse_tree.testsuite) can expect from the
    # environment.

    namespace import -force struct::tree

    set usec [time {source $tests} 1]

    puts "$impl:\t$usec"
}

catch {memory validate off}

unset usec
unset tests

puts ""

# Reset system to fully inactive state.

struct::tree::SwitchTo {}

# -------------------------------------------------------------------------

::tcltest::cleanupTests
return
