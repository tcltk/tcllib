# -*- tcl -*-
# Tests for the comm module.
#
# Sourcing this file into Tcl runs the tests and generates output for errors.
# No output means no errors were found.
#
# Copyright (c) 2001 by ActiveState Tool Corp.
# All rights reserved.
#
# RCS: @(#) $Id: comm.test,v 1.7 2006/01/29 06:15:34 andreas_kupries Exp $

# -------------------------------------------------------------------------

source [file join \
	[file dirname [file dirname [file join [pwd] [info script]]]] \
	devtools testutilities.tcl]

testsNeedTcl     8.2
testsNeedTcltest 1.0

testing {
    useLocal comm.tcl comm
}

# ------------------------------------------------------------------------
#
# First order of things is to spawn a separate tclsh into the background
# and have it execute comm too, with some general code to respond to our
# requests

set path(spawn) [makeFile {
    ##puts [set fh [open ~/foo w]] $argv ; close $fh

    source [lindex $argv 0].tcl ; # load 'comm'
    # and wait for commands. But first send our
    # own server socket to the initiator
    ::comm::comm send [lindex $argv 1] [list slaveat [::comm::comm self]]
    vwait forever
} spawn]

proc slaveat {id} {
    #puts "Slave @ $id"
    proc slave {} [list return $id]
    set ::go .
}

#puts "self @ [::comm::comm self]"

exec \
	[info nameofexecutable] $path(spawn) \
	[file rootname [info script]] [::comm::comm self] &

#puts "Waiting for spawned comm system to boot"
# Wait for the slave to initialize itself.
vwait ::go

#puts "Running tests"
#::comm::comm debug 1
# ------------------------------------------------------------------------

test comm-1.0 {set remote variable} {
    ::comm::comm send [slave] {set foo b}
} {b}

test comm-1.1 {set remote variable, async} {
    ::comm::comm send -async [slave] {set fox a}
} {}

test comm-1.2 {get remote variables} {
    ::comm::comm send [slave] {list $foo $fox}
} {b a}

test comm-1.3 {close remote} {
    ::comm::comm send -async [slave] {{exit}}
} {}

::comm::comm abort
removeFile spawn

::tcltest::cleanupTests
return
