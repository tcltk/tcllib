<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>struct::set - Tcl Data Structures</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.doctools_title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.doctools_toc,UL.doctools_toc UL, UL.doctools_toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.doctools_section, LI.doctools_subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.doctools_example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.doctools_requirements LI, UL.doctools_syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.doctools_synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.doctools_syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.doctools_requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<!-- Generated from file 'struct_set.man' by tcllib/doctools with format 'html'
   -->
<!-- Copyright &amp;copy; 2004-2008 Andreas Kupries &amp;lt;andreas_kupries@users.sourceforge.net&amp;gt;
   -->
<!-- struct::set.n
   -->
<body><hr> [
   <a href="../../../../../../../../home">Tcllib Home</a>
&#124; <a href="../../../../toc.html">Main Table Of Contents</a>
&#124; <a href="../../../toc.html">Table Of Contents</a>
&#124; <a href="../../../../index.html">Keyword Index</a>
&#124; <a href="../../../../toc0.html">Categories</a>
&#124; <a href="../../../../toc1.html">Modules</a>
&#124; <a href="../../../../toc2.html">Applications</a>
 ] <hr>
<div class="doctools">
<h1 class="doctools_title">struct::set(n) 2.2.5 tcllib &quot;Tcl Data Structures&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>struct::set - Commands for manipulating sets</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">COMMANDS</a></li>
<li class="doctools_section"><a href="#section3">EXAMPLES</a></li>
<li class="doctools_section"><a href="#section4">REFERENCES</a></li>
<li class="doctools_section"><a href="#section5">Bugs, Ideas, Feedback</a></li>
<li class="doctools_section"><a href="#keywords">Keywords</a></li>
<li class="doctools_section"><a href="#category">Category</a></li>
<li class="doctools_section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_requirements">
<li>package require <b class="pkgname">Tcl 8.5 9</b></li>
<li>package require <b class="pkgname">struct::set <span class="opt">?2.2.4?</span></b></li>
</ul>
<ul class="doctools_syntax">
<li><a href="#1"><b class="cmd">::struct::set</b> <b class="method">empty</b> <i class="arg">set</i></a></li>
<li><a href="#2"><b class="cmd">::struct::set</b> <b class="method">size</b> <i class="arg">set</i></a></li>
<li><a href="#3"><b class="cmd">::struct::set</b> <b class="method">contains</b> <i class="arg">set</i> <i class="arg">value</i></a></li>
<li><a href="#4"><b class="cmd">::struct::set</b> <b class="method">union</b> <span class="opt">?<i class="arg">set1</i>...?</span></a></li>
<li><a href="#5"><b class="cmd">::struct::set</b> <b class="method">intersect</b> <span class="opt">?<i class="arg">set1</i>...?</span></a></li>
<li><a href="#6"><b class="cmd">::struct::set</b> <b class="method">difference</b> <i class="arg">set1</i> <i class="arg">set2</i></a></li>
<li><a href="#7"><b class="cmd">::struct::set</b> <b class="method">symdiff</b> <i class="arg">set1</i> <i class="arg">set2</i></a></li>
<li><a href="#8"><b class="cmd">::struct::set</b> <b class="method">intersect3</b> <i class="arg">set1</i> <i class="arg">set2</i></a></li>
<li><a href="#9"><b class="cmd">::struct::set</b> <b class="method">equal</b> <i class="arg">set1</i> <i class="arg">set2</i></a></li>
<li><a href="#10"><b class="cmd">::struct::set</b> <b class="method">include</b> <i class="arg">setVar</i> <i class="arg">value</i></a></li>
<li><a href="#11"><b class="cmd">::struct::set</b> <b class="method">exclude</b> <i class="arg">setVar</i> <i class="arg">value</i></a></li>
<li><a href="#12"><b class="cmd">::struct::set</b> <b class="method">add</b> <i class="arg">setVar</i> <i class="arg">set</i></a></li>
<li><a href="#13"><b class="cmd">::struct::set</b> <b class="method">subtract</b> <i class="arg">setVar</i> <i class="arg">set</i></a></li>
<li><a href="#14"><b class="cmd">::struct::set</b> <b class="method">subsetof</b> <i class="arg">A</i> <i class="arg">B</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>The <b class="cmd">::struct::set</b> namespace contains several useful commands for
processing finite sets.</p>
<p>It exports only a single command, <b class="cmd">struct::set</b>. All the
functionality is available through this command’s subcommands.</p>
<p>A new empty set can be created using <b class="cmd">::struct::set add</b>
<i class="arg">setVar {}</i>.</p>
<p><em>Note:</em> As of version 2.2 of this package a critcl based C
implementation will be used where available, with Tcl 8.4 or later.</p>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">COMMANDS</a></h2>
<p>In the following, <i class="arg">set</i>, <i class="arg">set1</i>, and <i class="arg">set2</i> are <b class="type">set</b>
values and <i class="arg">setVar</i> is a <b class="type">set</b>’s variable name.</p>
<dl class="doctools_definitions">
<dt><a name="1"><b class="cmd">::struct::set</b> <b class="method">empty</b> <i class="arg">set</i></a></dt>
<dd><p>Returns <b class="const">1</b> (true) if the <i class="arg">set</i> is empty; otherwise returns
<b class="const">0</b> (false).</p></dd>
<dt><a name="2"><b class="cmd">::struct::set</b> <b class="method">size</b> <i class="arg">set</i></a></dt>
<dd><p>Returns the <i class="arg">set</i>’s cardinality, i.e., the number of elements in the
<i class="arg">set</i>. This could be zero.</p></dd>
<dt><a name="3"><b class="cmd">::struct::set</b> <b class="method">contains</b> <i class="arg">set</i> <i class="arg">value</i></a></dt>
<dd><p>Returns <b class="const">1</b> (true) if the <i class="arg">set</i> contains the
element <i class="arg">value</i>; otherwise returns <b class="const">0</b> (false).</p></dd>
<dt><a name="4"><b class="cmd">::struct::set</b> <b class="method">union</b> <span class="opt">?<i class="arg">set1</i>...?</span></a></dt>
<dd><p>Returns a <b class="type">set</b> consisting of the union of the given <b class="type">set</b>s,
i.e. <i class="arg">set1</i> ∪ <i class="arg">set2</i> ∪ …. The resulting <b class="type">set</b> will contain
every value in every given <b class="type">set</b>, with no duplicates.</p></dd>
<dt><a name="5"><b class="cmd">::struct::set</b> <b class="method">intersect</b> <span class="opt">?<i class="arg">set1</i>...?</span></a></dt>
<dd><p>Returns a <b class="type">set</b> consisting of the intersection of the given
<b class="type">set</b>s, i.e. <i class="arg">set1</i> ∩ <i class="arg">set2</i> ∩ …. The resulting <b class="type">set</b> will
contain every value that <em>every</em> one of the given <b class="type">set</b>s has in
common, with no duplicates.</p></dd>
<dt><a name="6"><b class="cmd">::struct::set</b> <b class="method">difference</b> <i class="arg">set1</i> <i class="arg">set2</i></a></dt>
<dd><p>Returns a <b class="type">set</b> consisting of the difference between <i class="arg">set1</i> and
<i class="arg">set2</i>, i.e., <i class="arg">set1</i> - <i class="arg">set2</i>. The resulting <b class="type">set</b> will
contain every value that is in <i class="arg">set1</i> but that is <em>not</em> in
<i class="arg">set2</i>.</p></dd>
<dt><a name="7"><b class="cmd">::struct::set</b> <b class="method">symdiff</b> <i class="arg">set1</i> <i class="arg">set2</i></a></dt>
<dd><p>Returns a <b class="type">set</b> consisting of the symmetric difference between
<i class="arg">set1</i> and <i class="arg">set2</i>, i.e., <i class="arg">set1</i> Δ <i class="arg">set2</i>. The resulting
<b class="type">set</b> will contain every value that is in <i class="arg">set1</i> <em>or</em> is in
<i class="arg">set2</i>, but <em>not</em> in both.</p></dd>
<dt><a name="8"><b class="cmd">::struct::set</b> <b class="method">intersect3</b> <i class="arg">set1</i> <i class="arg">set2</i></a></dt>
<dd><p>Returns a combination of the methods <b class="method">intersect</b> and
<b class="method">difference</b>.</p>
<p>The return value is a three-element list containing &quot;<i class="arg">set1</i> ∩
<i class="arg">set2</i>&quot;, &quot;<i class="arg">set1</i> - <i class="arg">set2</i>&quot;, and &quot;<i class="arg">set2</i> - <i class="arg">set1</i>&quot;,
in this order. In other words, the intersection of <i class="arg">set1</i> and
<i class="arg">set2</i>, and their differences.</p></dd>
<dt><a name="9"><b class="cmd">::struct::set</b> <b class="method">equal</b> <i class="arg">set1</i> <i class="arg">set2</i></a></dt>
<dd><p>Returns <b class="const">1</b> (true) if the two <b class="type">set</b>s contain exactly the same
values; otherwise returns <b class="const">0</b> (false).</p></dd>
<dt><a name="10"><b class="cmd">::struct::set</b> <b class="method">include</b> <i class="arg">setVar</i> <i class="arg">value</i></a></dt>
<dd><p>Adds element <i class="arg">value</i> to the <b class="type">set</b> called <i class="arg">setVar</i>, creating
<i class="arg">setVar</i> if it doesn’t exist. Harmlessly does nothing if <i class="arg">value</i> is
already in <b class="type">set</b> <i class="arg">setVar</i>. Returns nothing. This command can be
used to create new <b class="type">set</b>s.</p></dd>
<dt><a name="11"><b class="cmd">::struct::set</b> <b class="method">exclude</b> <i class="arg">setVar</i> <i class="arg">value</i></a></dt>
<dd><p>Removes element <i class="arg">value</i> from the <b class="type">set</b> called <i class="arg">setVar</i>.
If <i class="arg">value</i> isn’t in <i class="arg">setVar</i>, the command
harmlessly does nothing. Returns nothing.</p></dd>
<dt><a name="12"><b class="cmd">::struct::set</b> <b class="method">add</b> <i class="arg">setVar</i> <i class="arg">set</i></a></dt>
<dd><p>Adds every element from the <b class="type">set</b> value <i class="arg">set</i> to the <b class="type">set</b>
called <i class="arg">setVar</i>, excluding duplicates. The <b class="type">set</b> <i class="arg">setVar</i> is
created if it doesn’t exist. Returns nothing.</p>
<p>Use <b class="cmd">::struct::set add</b> <i class="arg">setVar {}</i> to create a new empty
set. Use <b class="cmd">::struct::set include</b> to add individual values.</p></dd>
<dt><a name="13"><b class="cmd">::struct::set</b> <b class="method">subtract</b> <i class="arg">setVar</i> <i class="arg">set</i></a></dt>
<dd><p>Removes every element from the <b class="type">set</b> value <i class="arg">set</i> from the
<b class="type">set</b> called <i class="arg">setVar</i>. Returns nothing. Use
<b class="cmd">::struct::set exclude</b> to remove individual values.</p></dd>
<dt><a name="14"><b class="cmd">::struct::set</b> <b class="method">subsetof</b> <i class="arg">A</i> <i class="arg">B</i></a></dt>
<dd><p>Returns <b class="const">1</b> (true) if <i class="arg">A</i> ⊆ <i class="arg">B</i>, i.e., if <b class="type">set</b>
<i class="arg">A</i> is a true subset of or equal to the <b class="type">set</b> <i class="arg">B</i>;
otherwise returns <b class="const">0</b> (false).</p></dd>
</dl>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">EXAMPLES</a></h2>
<p>Creating and populating a new <b class="type">set</b> from scratch. The
<b class="variable">earth_metals</b> <b class="type">set</b> will be created on the first
iteration of the loop and added to on subsequent iterations.</p>
<pre class="doctools_example">
foreach element {Be Mg Ca Sr Ba Ra} {
    struct::set include earth_metals $element
}</pre>
<p>Creating a <b class="type">set</b> by unioning a couple of existing <b class="type">set</b>s.</p>
<pre class="doctools_example">
set metals [struct::set union $alkali_metals $earth_metals]
</pre>
<p>Querying a <b class="type">set</b>’s properties.</p>
<pre class="doctools_example">
if {[struct::set empty $metals]} {
    puts &quot;empty&quot;
} else {
    puts &quot;[struct::set size $metals] elements&quot;
}</pre>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">REFERENCES</a></h2>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">Bugs, Ideas, Feedback</a></h2>
<p>If you find errors in this document or bugs or problems with the
package it describes, or if you want to suggest improvements for the
documentation or the package, please use the
<a href="http://core.tcl.tk/tcllib/reportlist">Tcllib Trackers</a> and specify 
<em>struct :: set</em> as the category.</p>
<p>When proposing code changes, please provide <em>unified diffs</em>,
i.e the output of <b class="const">diff -u</b>.</p>
<p>Note further that <em>attachments</em> are strongly preferred over
inlined patches. Attachments can be made by going to the <b class="const">Edit</b>
form of the ticket immediately after its creation, and then using the
left-most button in the secondary navigation bar.</p>
</div>
<div id="keywords" class="doctools_section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../../../../index.html#cardinality">cardinality</a>, <a href="../../../../index.html#difference">difference</a>, <a href="../../../../index.html#emptiness">emptiness</a>, <a href="../../../../index.html#exclusion">exclusion</a>, <a href="../../../../index.html#inclusion">inclusion</a>, <a href="../../../../index.html#intersection">intersection</a>, <a href="../../../../index.html#membership">membership</a>, <a href="../../../../index.html#set">set</a>, <a href="../../../../index.html#symmetric_difference">symmetric difference</a>, <a href="../../../../index.html#union">union</a></p>
</div>
<div id="category" class="doctools_section"><h2><a name="category">Category</a></h2>
<p>Data structures</p>
</div>
<div id="copyright" class="doctools_section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2004-2008 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;</p>
</div>
</div></body></html>
